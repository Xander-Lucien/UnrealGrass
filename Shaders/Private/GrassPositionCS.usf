// GrassPositionCS.usf
// GPU Grass Position and Instance Data Generation with Voronoi Clump Distribution

#include "/Engine/Public/Platform.ush"

// Output buffers
RWStructuredBuffer<float3> OutPositions;
RWStructuredBuffer<float4> OutGrassData0;  // Height, Width, Tilt, Bend
RWStructuredBuffer<float4> OutGrassData1;  // TaperAmount, FacingDir.x, FacingDir.y, P1Offset
RWStructuredBuffer<float> OutGrassData2;   // P2Offset

// Basic parameters
int GridSize;
float Spacing;
float JitterStrength;

// Clump parameters
int NumClumps;
int NumClumpTypes;
float PullToCentre;
float PointInSameDirection;

// Grass blade parameters
float BaseHeight;
float HeightRandom;
float BaseWidth;
float WidthRandom;
float BaseTilt;
float TiltRandom;
float BaseBend;
float BendRandom;
float TaperAmount;

float Hash(float2 p)
{
    return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453);
}

float2 Hash22(float2 p)
{
    float3 a = frac(float3(p.x, p.y, p.x) * float3(123.34, 234.34, 345.65));
    a += dot(a, a + 34.45);
    return frac(float2(a.x * a.y, a.y * a.z));
}

float2 Random2D(float2 seed)
{
    return float2(
        Hash(seed) * 2.0 - 1.0,
        Hash(seed + float2(1.0, 0.0)) * 2.0 - 1.0
    );
}

float4 GetVoronoi(float2 UV, int ClumpCount, int ClumpTypeCount)
{
    float MinDist = 100000.0;
    float Id = 0.0;
    float2 ClumpCentre = float2(0.0, 0.0);
    
    int ClumpLimit = min(100, ClumpCount);
    
    for (int j = 1; j < ClumpLimit; j++)
    {
        float2 JJ = float2((float)j, (float)j);
        float2 P = Hash22(JJ);
        float D = distance(P, UV);
        
        if (D < MinDist)
        {
            MinDist = D;
            Id = fmod((float)j, (float)ClumpTypeCount);
            ClumpCentre = P;
        }
    }
    
    return float4(Id, ClumpCentre.x, ClumpCentre.y, MinDist);
}

[numthreads(8, 8, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    int x = DispatchThreadId.x;
    int y = DispatchThreadId.y;
    
    if (x >= GridSize || y >= GridSize)
        return;
    
    int Index = y * GridSize + x;
    float HalfSize = (GridSize - 1) * Spacing * 0.5;
    
    // Base position
    float3 Position;
    Position.x = x * Spacing - HalfSize;
    Position.y = y * Spacing - HalfSize;
    Position.z = 0;
    
    // Jitter
    float2 Jitter = Random2D(float2(x, y)) * Spacing * JitterStrength * 0.5;
    Position.x += Jitter.x;
    Position.y += Jitter.y;
    
    // UV for Voronoi
    float2 UV = float2(
        (Position.x + HalfSize) / (HalfSize * 2.0),
        (Position.y + HalfSize) / (HalfSize * 2.0)
    );
    UV = saturate(UV);
    
    // Get Voronoi data
    float4 VoronoiData = GetVoronoi(UV, NumClumps, NumClumpTypes);
    float ClumpId = VoronoiData.x;
    float2 ClumpCentre = VoronoiData.yz;
    
    // World space clump center
    float2 ClumpCentreWorld = float2(
        ClumpCentre.x * HalfSize * 2.0 - HalfSize,
        ClumpCentre.y * HalfSize * 2.0 - HalfSize
    );
    
    // Pull to centre
    float2 ToCentre = ClumpCentreWorld - Position.xy;
    Position.x += ToCentre.x * PullToCentre;
    Position.y += ToCentre.y * PullToCentre;
    
    // Random seeds for this instance
    float2 Seed1 = float2(x * 0.1 + 0.5, y * 0.1 + 0.7);
    float2 Seed2 = float2(x * 0.2 + 1.3, y * 0.2 + 2.1);
    float2 Seed3 = float2(x * 0.3 + 3.7, y * 0.3 + 4.9);
    float2 Seed4 = float2(x * 0.4 + 5.2, y * 0.4 + 6.8);
    
    // Grass blade properties with randomization
    float Height = BaseHeight + (Hash(Seed1) * 2.0 - 1.0) * HeightRandom;
    float Width = BaseWidth + (Hash(Seed2) * 2.0 - 1.0) * WidthRandom;
    float Tilt = BaseTilt + (Hash(Seed3) * 2.0 - 1.0) * TiltRandom;
    float Bend = BaseBend + (Hash(Seed4) * 2.0 - 1.0) * BendRandom;
    
    // Clamp values
    Height = max(Height, 1.0);
    Width = max(Width, 0.1);
    Tilt = saturate(Tilt);
    Bend = saturate(Bend);
    
    // Facing direction - mix individual random with clump direction
    float2 ClumpDir = Random2D(float2(ClumpId * 100.0, ClumpId * 50.0));
    float ClumpDirLen = length(ClumpDir);
    if (ClumpDirLen > 0.001) ClumpDir = ClumpDir / ClumpDirLen;
    
    float2 IndividualDir = Random2D(float2(x * 0.15, y * 0.15));
    float IndividualDirLen = length(IndividualDir);
    if (IndividualDirLen > 0.001) IndividualDir = IndividualDir / IndividualDirLen;
    
    float2 FacingDir = lerp(IndividualDir, ClumpDir, PointInSameDirection);
    float FacingDirLen = length(FacingDir);
    if (FacingDirLen > 0.001) FacingDir = FacingDir / FacingDirLen;
    
    // Bezier control point offsets
    float P1Offset = Hash(Seed1 + float2(10.0, 20.0)) * 0.3;
    float P2Offset = Hash(Seed2 + float2(30.0, 40.0)) * 0.5;
    
    // Write outputs
    OutPositions[Index] = Position;
    OutGrassData0[Index] = float4(Height, Width, Tilt, Bend);
    OutGrassData1[Index] = float4(TaperAmount, FacingDir.x, FacingDir.y, P1Offset);
    OutGrassData2[Index] = P2Offset;
}

