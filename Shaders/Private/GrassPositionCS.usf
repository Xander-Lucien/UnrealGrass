// GrassPositionCS.usf
// GPU Grass Position and Instance Data Generation with Clump Buffer
// 使用预生成的 ClumpBuffer 来查找最近的 Clump

#include "/Engine/Public/Platform.ush"

// 输入 Buffers - Clump 数据
// ClumpData0: Centre.x, Centre.y, Direction.x, Direction.y
// ClumpData1: HeightScale, WidthScale, WindPhase, Padding
StructuredBuffer<float4> InClumpData0;
StructuredBuffer<float4> InClumpData1;

// Output buffers
RWStructuredBuffer<float3> OutPositions;
RWStructuredBuffer<float4> OutGrassData0;  // Height, Width, Tilt, Bend
RWStructuredBuffer<float4> OutGrassData1;  // TaperAmount, FacingDir.x, FacingDir.y, P1Offset
RWStructuredBuffer<float> OutGrassData2;   // P2Offset

// Basic parameters
int GridSize;
float Spacing;
float JitterStrength;

// Clump parameters
int NumClumps;
int NumClumpTypes;
float PullToCentre;
float PointInSameDirection;

// Grass blade parameters
float BaseHeight;
float HeightRandom;
float BaseWidth;
float WidthRandom;
float BaseTilt;
float TiltRandom;
float BaseBend;
float BendRandom;
float TaperAmount;

// ============================================================================
// 哈希函数
// ============================================================================
float Hash(float2 p)
{
    return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453);
}

float2 Hash22(float2 p)
{
    float3 a = frac(float3(p.x, p.y, p.x) * float3(123.34, 234.34, 345.65));
    a += dot(a, a + 34.45);
    return frac(float2(a.x * a.y, a.y * a.z));
}

float2 Random2D(float2 seed)
{
    return float2(
        Hash(seed) * 2.0 - 1.0,
        Hash(seed + float2(1.0, 0.0)) * 2.0 - 1.0
    );
}

// ============================================================================
// 从 ClumpBuffer 中查找最近的 Clump
// 返回: x=ClumpIndex, y=ClumpCentre.x, z=ClumpCentre.y, w=Distance
// ============================================================================
float4 FindNearestClump(float2 UV, int ClumpCount)
{
    float MinDist = 100000.0;
    int NearestClumpIndex = 0;
    float2 NearestCentre = float2(0.0, 0.0);
    
    int ClumpLimit = min(100, ClumpCount);
    
    for (int j = 0; j < ClumpLimit; j++)
    {
        // 从 ClumpBuffer 读取 Clump 中心位置
        float4 ClumpData = InClumpData0[j];
        float2 ClumpCentre = ClumpData.xy;
        
        float D = distance(ClumpCentre, UV);
        
        if (D < MinDist)
        {
            MinDist = D;
            NearestClumpIndex = j;
            NearestCentre = ClumpCentre;
        }
    }
    
    return float4((float)NearestClumpIndex, NearestCentre.x, NearestCentre.y, MinDist);
}

// ============================================================================
// 主函数
// ============================================================================
[numthreads(8, 8, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    int x = DispatchThreadId.x;
    int y = DispatchThreadId.y;
    
    if (x >= GridSize || y >= GridSize)
        return;
    
    int Index = y * GridSize + x;
    float HalfSize = (GridSize - 1) * Spacing * 0.5;
    
    // Base position
    float3 Position;
    Position.x = x * Spacing - HalfSize;
    Position.y = y * Spacing - HalfSize;
    Position.z = 0;
    
    // Jitter
    float2 Jitter = Random2D(float2(x, y)) * Spacing * JitterStrength * 0.5;
    Position.x += Jitter.x;
    Position.y += Jitter.y;
    
    // UV for finding nearest clump
    float2 UV = float2(
        (Position.x + HalfSize) / (HalfSize * 2.0),
        (Position.y + HalfSize) / (HalfSize * 2.0)
    );
    UV = saturate(UV);
    
    // 从 ClumpBuffer 查找最近的 Clump
    float4 ClumpResult = FindNearestClump(UV, NumClumps);
    int ClumpIndex = (int)ClumpResult.x;
    float2 ClumpCentre = ClumpResult.yz;
    
    // 从 ClumpBuffer 读取 Clump 属性
    float4 ClumpData0 = InClumpData0[ClumpIndex]; // Centre.xy, Direction.xy
    float4 ClumpData1 = InClumpData1[ClumpIndex]; // HeightScale, WidthScale, WindPhase, Padding
    
    float2 ClumpDirection = ClumpData0.zw;
    float ClumpHeightScale = ClumpData1.x;
    float ClumpWidthScale = ClumpData1.y;
    // float ClumpWindPhase = ClumpData1.z; // 未来可用于风动画
    
    // World space clump center
    float2 ClumpCentreWorld = float2(
        ClumpCentre.x * HalfSize * 2.0 - HalfSize,
        ClumpCentre.y * HalfSize * 2.0 - HalfSize
    );
    
    // Pull to centre
    float2 ToCentre = ClumpCentreWorld - Position.xy;
    Position.x += ToCentre.x * PullToCentre;
    Position.y += ToCentre.y * PullToCentre;
    
    // Random seeds for this instance
    float2 Seed1 = float2(x * 0.1 + 0.5, y * 0.1 + 0.7);
    float2 Seed2 = float2(x * 0.2 + 1.3, y * 0.2 + 2.1);
    float2 Seed3 = float2(x * 0.3 + 3.7, y * 0.3 + 4.9);
    float2 Seed4 = float2(x * 0.4 + 5.2, y * 0.4 + 6.8);
    
    // Grass blade properties with randomization
    // 应用 Clump 级别的缩放
    float Height = (BaseHeight + (Hash(Seed1) * 2.0 - 1.0) * HeightRandom) * ClumpHeightScale;
    float Width = (BaseWidth + (Hash(Seed2) * 2.0 - 1.0) * WidthRandom) * ClumpWidthScale;
    float Tilt = BaseTilt + (Hash(Seed3) * 2.0 - 1.0) * TiltRandom;
    float Bend = BaseBend + (Hash(Seed4) * 2.0 - 1.0) * BendRandom;
    
    // Clamp values
    Height = max(Height, 1.0);
    Width = max(Width, 0.1);
    Tilt = saturate(Tilt);
    Bend = saturate(Bend);
    
    // Facing direction - 使用 ClumpBuffer 中预计算的 Clump 朝向
    float2 IndividualDir = Random2D(float2(x * 0.15, y * 0.15));
    float IndividualDirLen = length(IndividualDir);
    if (IndividualDirLen > 0.001) IndividualDir = IndividualDir / IndividualDirLen;
    
    float2 FacingDir = lerp(IndividualDir, ClumpDirection, PointInSameDirection);
    float FacingDirLen = length(FacingDir);
    if (FacingDirLen > 0.001) FacingDir = FacingDir / FacingDirLen;
    
    // Bezier control point offsets
    float P1Offset = Hash(Seed1 + float2(10.0, 20.0)) * 0.3;
    float P2Offset = Hash(Seed2 + float2(30.0, 40.0)) * 0.5;
    
    // Write outputs
    OutPositions[Index] = Position;
    OutGrassData0[Index] = float4(Height, Width, Tilt, Bend);
    OutGrassData1[Index] = float4(TaperAmount, FacingDir.x, FacingDir.y, P1Offset);
    OutGrassData2[Index] = P2Offset;
}

