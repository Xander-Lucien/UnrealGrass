// GrassPositionCS.usf
// GPU Grass Position and Instance Data Generation
// 直接遍历 Clump Buffer 查找最近的 Clump (对马岛之魂方案)
//
// 算法：
// 每个草叶线程遍历所有 Clump，找到距离最近的 Clump
// Clump 数量有限（最多 256 个），GPU 并行下遍历成本极低
// 不依赖 Voronoi 纹理，天然支持任意 Tile 和世界空间扩展

#include "/Engine/Public/Platform.ush"

// 输入 - Landscape 高度图 Texture (RGBA8, RG=高度, BA=法线)
Texture2D InLandscapeHeightmap;
SamplerState InLandscapeHeightmapSampler;

// 输入 Buffers - Clump 属性数据
// ClumpData0: Centre.x, Centre.y, Direction.x, Direction.y
// ClumpData1: HeightScale, WidthScale, WindPhase, ClumpTypeIndex
StructuredBuffer<float4> InClumpData0;
StructuredBuffer<float4> InClumpData1;

// 输入 Buffer - 每种簇类型的参数
// 每种类型占用 3 个 float4:
// [TypeIndex * 3 + 0]: PullToCentre, PointInSameDirection, BaseHeight, HeightRandom
// [TypeIndex * 3 + 1]: BaseWidth, WidthRandom, BaseTilt, TiltRandom
// [TypeIndex * 3 + 2]: BaseBend, BendRandom, Reserved, Reserved
StructuredBuffer<float4> InClumpTypeParams;

// Output buffers
RWStructuredBuffer<float3> OutPositions;
RWStructuredBuffer<float4> OutGrassData0;  // Height, Width, Tilt, Bend
RWStructuredBuffer<float4> OutGrassData1;  // TaperAmount, FacingDir.x, FacingDir.y, P1Offset
RWStructuredBuffer<float> OutGrassData2;   // P2Offset

// Basic parameters
int GridSize;
float Spacing;
float JitterStrength;

// Clump parameters
int NumClumps;
int NumClumpTypes;

// Landscape 高度图参数
float4 HeightmapScaleBias;       // UV 缩放(xy) 和偏移(zw)，从 LandscapeComponent 获取
float3 LandscapeScale;           // Landscape 的世界缩放 (GetActorScale3D)
float3 LandscapeLocation;        // Landscape 的世界位置 (GetActorLocation)
float2 ComponentWorldOrigin;     // Component 在世界空间中的 XY 原点
float ComponentWorldSizeX;       // Component 在世界空间中的 X 尺寸
float ComponentWorldSizeY;       // Component 在世界空间中的 Y 尺寸
int bUseLandscapeHeightmap;      // 是否启用 Landscape 高度图 (0 或 1)

// 全局草叶参数 (所有簇类型共享)
float TaperAmount;

// ============================================================================
// 哈希函数
// ============================================================================
float Hash(float2 p)
{
    return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453);
}

float2 Hash22(float2 p)
{
    float3 a = frac(float3(p.x, p.y, p.x) * float3(123.34, 234.34, 345.65));
    a += dot(a, a + 34.45);
    return frac(float2(a.x * a.y, a.y * a.z));
}

float2 Random2D(float2 seed)
{
    return float2(
        Hash(seed) * 2.0 - 1.0,
        Hash(seed + float2(1.0, 0.0)) * 2.0 - 1.0
    );
}

// ============================================================================
// 从 ClumpTypeParams Buffer 读取指定类型的参数
// ============================================================================
struct FClumpTypeData
{
    float PullToCentre;
    float PointInSameDirection;
    float BaseHeight;
    float HeightRandom;
    float BaseWidth;
    float WidthRandom;
    float BaseTilt;
    float TiltRandom;
    float BaseBend;
    float BendRandom;
};

FClumpTypeData GetClumpTypeData(int TypeIndex)
{
    FClumpTypeData Data;
    
    int BaseIdx = TypeIndex * 3;
    float4 Params0 = InClumpTypeParams[BaseIdx + 0];
    float4 Params1 = InClumpTypeParams[BaseIdx + 1];
    float4 Params2 = InClumpTypeParams[BaseIdx + 2];
    
    Data.PullToCentre = Params0.x;
    Data.PointInSameDirection = Params0.y;
    Data.BaseHeight = Params0.z;
    Data.HeightRandom = Params0.w;
    
    Data.BaseWidth = Params1.x;
    Data.WidthRandom = Params1.y;
    Data.BaseTilt = Params1.z;
    Data.TiltRandom = Params1.w;
    
    Data.BaseBend = Params2.x;
    Data.BendRandom = Params2.y;
    
    return Data;
}

// ============================================================================
// Landscape 高度图解码函数 (与引擎 Common.ush 中的 DecodePackedHeight 一致)
// ============================================================================
#define TERRAIN_ZSCALE (1.0f/128.0f)

float DecodePackedTwoChannelValue(float2 PackedHeight)
{
    return PackedHeight.x * 255.0 * 256.0 + PackedHeight.y * 255.0;
}

float DecodeHeightValue(float InValue)
{
    return (InValue - 32768.0) * TERRAIN_ZSCALE;
}

float DecodePackedHeight(float2 PackedHeight)
{
    return DecodeHeightValue(DecodePackedTwoChannelValue(PackedHeight));
}

// ============================================================================
// Landscape 高度图采样函数
// ============================================================================
float SampleLandscapeHeight(float2 WorldPos)
{
    // 世界坐标 → Component 局部坐标（以 quad 为单位）
    float2 LocalQuadPos = (WorldPos - ComponentWorldOrigin) / LandscapeScale.xy;
    
    // 局部 quad 坐标 → 高度图 UV (使用 HeightmapScaleBias 定位到 Atlas 中的正确区域)
    // HeightmapScaleBias.xy = UV 缩放 (每个 quad 在 UV 中占多大)
    // HeightmapScaleBias.zw = UV 偏移 (Component 在 Atlas 中的起始位置)
    // +0.5 * ScaleBias.xy 是半像素偏移，对齐到纹素中心
    float2 HeightmapUV = LocalQuadPos * HeightmapScaleBias.xy + HeightmapScaleBias.zw + 0.5 * HeightmapScaleBias.xy;
    
    // 采样 Landscape 高度图纹理 (RGBA8 格式, RG 通道存储 16-bit 高度值)
    float4 Sample = InLandscapeHeightmap.SampleLevel(InLandscapeHeightmapSampler, HeightmapUV, 0);
    
    // 解码高度值: (R*255*256 + G*255 - 32768) / 128 → 得到 local Z
    float LocalHeight = DecodePackedHeight(Sample.xy);
    
    // 转换到世界高度: LocalHeight * Scale.Z + Location.Z
    return LocalHeight * LandscapeScale.z + LandscapeLocation.z;
}

// ============================================================================
// 主函数
// ============================================================================
[numthreads(8, 8, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    int x = DispatchThreadId.x;
    int y = DispatchThreadId.y;
    
    if (x >= GridSize || y >= GridSize)
        return;
    
    int Index = y * GridSize + x;
    
    // ========== 位置生成: 当启用 Landscape Heightmap 时铺满整个 Component ==========
    // 注意: Position 是相对于 Actor 中心的本地坐标
    // 当 bUseLandscapeHeightmap 时，Actor 已被移动到 Component 中心
    // 所以 HalfSize = CompWorldSize * 0.5 就能让网格覆盖整个 Component
    float HalfSizeX = (GridSize - 1) * Spacing * 0.5;
    float HalfSizeY = HalfSizeX;
    
    // 如果启用了 Landscape Heightmap，使用 Component 尺寸作为范围
    if (bUseLandscapeHeightmap > 0 && ComponentWorldSizeX > 0 && ComponentWorldSizeY > 0)
    {
        HalfSizeX = ComponentWorldSizeX * 0.5;
        HalfSizeY = ComponentWorldSizeY * 0.5;
    }
    
    // Base position (本地坐标，相对于 Actor 中心)
    float3 Position;
    Position.x = ((float)x / (float)(GridSize - 1)) * HalfSizeX * 2.0 - HalfSizeX;
    Position.y = ((float)y / (float)(GridSize - 1)) * HalfSizeY * 2.0 - HalfSizeY;
    Position.z = 0;
    
    // Jitter (使用 Spacing 作为 jitter 单元大小)
    float JitterCellSize = Spacing;
    if (bUseLandscapeHeightmap > 0 && ComponentWorldSizeX > 0)
    {
        // 当铺满 Component 时，jitter 基于网格单元格大小
        JitterCellSize = ComponentWorldSizeX / (float)(GridSize - 1);
    }
    float2 Jitter = Random2D(float2(x, y)) * JitterCellSize * JitterStrength * 0.5;
    Position.x += Jitter.x;
    Position.y += Jitter.y;
    
    // ========== 从 Landscape 高度图采样获取地形高度 ==========
    // 重要: Position.xy 是本地坐标，需要加上 Component 中心坐标才是世界坐标
    if (bUseLandscapeHeightmap > 0)
    {
        float2 WorldPosXY = Position.xy + ComponentWorldOrigin + float2(ComponentWorldSizeX, ComponentWorldSizeY) * 0.5;
        float WorldHeight = SampleLandscapeHeight(WorldPosXY);
        // 高度保存为相对于 Actor 中心的本地 Z (Actor 已在 Component 中心)
        Position.z = WorldHeight;
    }
    
    // ========== 直接遍历 Clump Buffer 查找最近的 Clump ==========
    // Clump 中心点存储在 UV 空间 (0-1)，需要转换到本地空间进行距离比较
    float MinDist = 1e10;
    int NearestClumpIndex = 0;
    float2 NearestClumpCentreLocal = float2(0, 0);
    
    int ClumpLimit = min(256, NumClumps);
    
    for (int j = 0; j < ClumpLimit; j++)
    {
        float4 ClumpData = InClumpData0[j];
        float2 ClumpCentreUV = ClumpData.xy;
        
        // 将 Clump 中心从 UV 空间转换到本地空间
        float2 ClumpCentreLocal = float2(
            ClumpCentreUV.x * HalfSizeX * 2.0 - HalfSizeX,
            ClumpCentreUV.y * HalfSizeY * 2.0 - HalfSizeY
        );
        
        float D = distance(Position.xy, ClumpCentreLocal);
        
        if (D < MinDist)
        {
            MinDist = D;
            NearestClumpIndex = j;
            NearestClumpCentreLocal = ClumpCentreLocal;
        }
    }
    
    // 从 ClumpBuffer 读取 Clump 属性
    float4 ClumpData0 = InClumpData0[NearestClumpIndex]; // Centre.xy, Direction.xy
    float4 ClumpData1 = InClumpData1[NearestClumpIndex]; // HeightScale, WidthScale, WindPhase, ClumpTypeIndex
    
    float2 ClumpDirection = ClumpData0.zw;
    float ClumpHeightScale = ClumpData1.x;
    float ClumpWidthScale = ClumpData1.y;
    // float ClumpWindPhase = ClumpData1.z; // 未来可用于风动画
    
    // 获取这个 Clump 的类型索引，并读取对应类型的参数
    int ClumpTypeIndex = (int)(ClumpData1.w + 0.5);
    ClumpTypeIndex = clamp(ClumpTypeIndex, 0, NumClumpTypes - 1);
    FClumpTypeData TypeData = GetClumpTypeData(ClumpTypeIndex);
    
    // Pull to centre - 使用每种类型独立的参数
    float2 ToCentre = NearestClumpCentreLocal - Position.xy;
    Position.x += ToCentre.x * TypeData.PullToCentre;
    Position.y += ToCentre.y * TypeData.PullToCentre;
    
    // Random seeds for this instance
    float2 Seed1 = float2(x * 0.1 + 0.5, y * 0.1 + 0.7);
    float2 Seed2 = float2(x * 0.2 + 1.3, y * 0.2 + 2.1);
    float2 Seed3 = float2(x * 0.3 + 3.7, y * 0.3 + 4.9);
    float2 Seed4 = float2(x * 0.4 + 5.2, y * 0.4 + 6.8);
    
    // Grass blade properties with randomization - 使用每种类型独立的参数
    // 应用 Clump 级别的缩放
    float Height = (TypeData.BaseHeight + (Hash(Seed1) * 2.0 - 1.0) * TypeData.HeightRandom) * ClumpHeightScale;
    float Width = (TypeData.BaseWidth + (Hash(Seed2) * 2.0 - 1.0) * TypeData.WidthRandom) * ClumpWidthScale;
    float Tilt = TypeData.BaseTilt + (Hash(Seed3) * 2.0 - 1.0) * TypeData.TiltRandom;
    float Bend = TypeData.BaseBend + (Hash(Seed4) * 2.0 - 1.0) * TypeData.BendRandom;
    
    // Clamp values
    Height = max(Height, 1.0);
    Width = max(Width, 0.1);
    Tilt = saturate(Tilt);
    Bend = saturate(Bend);
    
    // Facing direction - 使用 ClumpBuffer 中预计算的 Clump 朝向和每种类型独立的一致性参数
    float2 IndividualDir = Random2D(float2(x * 0.15, y * 0.15));
    float IndividualDirLen = length(IndividualDir);
    if (IndividualDirLen > 0.001) IndividualDir = IndividualDir / IndividualDirLen;
    
    float2 FacingDir = lerp(IndividualDir, ClumpDirection, TypeData.PointInSameDirection);
    float FacingDirLen = length(FacingDir);
    if (FacingDirLen > 0.001) FacingDir = FacingDir / FacingDirLen;
    
    // Bezier control point offsets
    float P1Offset = Hash(Seed1 + float2(10.0, 20.0)) * 0.3;
    float P2Offset = Hash(Seed2 + float2(30.0, 40.0)) * 0.5;
    
    // Write outputs
    OutPositions[Index] = Position;
    OutGrassData0[Index] = float4(Height, Width, Tilt, Bend);
    OutGrassData1[Index] = float4(TaperAmount, FacingDir.x, FacingDir.y, P1Offset);
    OutGrassData2[Index] = P2Offset;
}