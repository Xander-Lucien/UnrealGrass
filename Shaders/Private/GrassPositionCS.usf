// GrassPositionCS.usf
// GPU Grass Position and Instance Data Generation with Voronoi Texture
// 使用预生成的 Voronoi Texture 采样获取最近的 Clump (O(1) 复杂度)
//
// 算法改进：
// 旧方案：每个草叶循环遍历所有 Clump 查找最近的 O(N)
// 新方案：从预计算的 Voronoi Texture 采样，O(1) 复杂度
//
// Voronoi Texture 格式 (RGBA float):
// R = ClumpIndex (归一化 0-1，需乘以 255)
// G = ClumpCentre.x (0-1)
// B = ClumpCentre.y (0-1)
// A = Distance (归一化)

#include "/Engine/Public/Platform.ush"

// 输入 - Voronoi Texture (预计算的 Clump 查找表)
Texture2D<float4> InVoronoiTexture;
SamplerState InVoronoiTextureSampler;

// 输入 Buffers - Clump 属性数据
// ClumpData0: Centre.x, Centre.y, Direction.x, Direction.y
// ClumpData1: HeightScale, WidthScale, WindPhase, ClumpTypeIndex
StructuredBuffer<float4> InClumpData0;
StructuredBuffer<float4> InClumpData1;

// 输入 Buffer - 每种簇类型的参数
// 每种类型占用 3 个 float4:
// [TypeIndex * 3 + 0]: PullToCentre, PointInSameDirection, BaseHeight, HeightRandom
// [TypeIndex * 3 + 1]: BaseWidth, WidthRandom, BaseTilt, TiltRandom
// [TypeIndex * 3 + 2]: BaseBend, BendRandom, Reserved, Reserved
StructuredBuffer<float4> InClumpTypeParams;

// Output buffers
RWStructuredBuffer<float3> OutPositions;
RWStructuredBuffer<float4> OutGrassData0;  // Height, Width, Tilt, Bend
RWStructuredBuffer<float4> OutGrassData1;  // TaperAmount, FacingDir.x, FacingDir.y, P1Offset
RWStructuredBuffer<float> OutGrassData2;   // P2Offset

// Basic parameters
int GridSize;
float Spacing;
float JitterStrength;

// Clump parameters
int NumClumps;
int NumClumpTypes;

// 全局草叶参数 (所有簇类型共享)
float TaperAmount;

// ============================================================================
// 哈希函数
// ============================================================================
float Hash(float2 p)
{
    return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453);
}

float2 Hash22(float2 p)
{
    float3 a = frac(float3(p.x, p.y, p.x) * float3(123.34, 234.34, 345.65));
    a += dot(a, a + 34.45);
    return frac(float2(a.x * a.y, a.y * a.z));
}

float2 Random2D(float2 seed)
{
    return float2(
        Hash(seed) * 2.0 - 1.0,
        Hash(seed + float2(1.0, 0.0)) * 2.0 - 1.0
    );
}

// ============================================================================
// 从 ClumpTypeParams Buffer 读取指定类型的参数
// ============================================================================
struct FClumpTypeData
{
    float PullToCentre;
    float PointInSameDirection;
    float BaseHeight;
    float HeightRandom;
    float BaseWidth;
    float WidthRandom;
    float BaseTilt;
    float TiltRandom;
    float BaseBend;
    float BendRandom;
};

FClumpTypeData GetClumpTypeData(int TypeIndex)
{
    FClumpTypeData Data;
    
    int BaseIdx = TypeIndex * 3;
    float4 Params0 = InClumpTypeParams[BaseIdx + 0];
    float4 Params1 = InClumpTypeParams[BaseIdx + 1];
    float4 Params2 = InClumpTypeParams[BaseIdx + 2];
    
    Data.PullToCentre = Params0.x;
    Data.PointInSameDirection = Params0.y;
    Data.BaseHeight = Params0.z;
    Data.HeightRandom = Params0.w;
    
    Data.BaseWidth = Params1.x;
    Data.WidthRandom = Params1.y;
    Data.BaseTilt = Params1.z;
    Data.TiltRandom = Params1.w;
    
    Data.BaseBend = Params2.x;
    Data.BendRandom = Params2.y;
    
    return Data;
}

// ============================================================================
// 主函数
// ============================================================================
[numthreads(8, 8, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    int x = DispatchThreadId.x;
    int y = DispatchThreadId.y;
    
    if (x >= GridSize || y >= GridSize)
        return;
    
    int Index = y * GridSize + x;
    float HalfSize = (GridSize - 1) * Spacing * 0.5;
    
    // Base position
    float3 Position;
    Position.x = x * Spacing - HalfSize;
    Position.y = y * Spacing - HalfSize;
    Position.z = 0;
    
    // Jitter
    float2 Jitter = Random2D(float2(x, y)) * Spacing * JitterStrength * 0.5;
    Position.x += Jitter.x;
    Position.y += Jitter.y;
    
    // UV for Voronoi texture sampling
    float2 UV = float2(
        (Position.x + HalfSize) / (HalfSize * 2.0),
        (Position.y + HalfSize) / (HalfSize * 2.0)
    );
    UV = saturate(UV);
    
    // ========== 从 Voronoi Texture 采样获取最近 Clump (O(1) 复杂度！) ==========
    float4 VoronoiData = InVoronoiTexture.SampleLevel(InVoronoiTextureSampler, UV, 0);
    
    // 解析 Voronoi 数据
    int ClumpIndex = (int)(VoronoiData.r * 255.0 + 0.5); // 从归一化值恢复索引
    ClumpIndex = clamp(ClumpIndex, 0, NumClumps - 1);    // 确保索引有效
    float2 ClumpCentre = VoronoiData.gb;                  // 直接从纹理获取 Clump 中心
    // float VoronoiDistance = VoronoiData.a;             // 距离（如果需要的话）
    
    // 从 ClumpBuffer 读取 Clump 属性
    float4 ClumpData0 = InClumpData0[ClumpIndex]; // Centre.xy, Direction.xy
    float4 ClumpData1 = InClumpData1[ClumpIndex]; // HeightScale, WidthScale, WindPhase, ClumpTypeIndex
    
    float2 ClumpDirection = ClumpData0.zw;
    float ClumpHeightScale = ClumpData1.x;
    float ClumpWidthScale = ClumpData1.y;
    // float ClumpWindPhase = ClumpData1.z; // 未来可用于风动画
    
    // 获取这个 Clump 的类型索引，并读取对应类型的参数
    int ClumpTypeIndex = (int)(ClumpData1.w + 0.5);
    ClumpTypeIndex = clamp(ClumpTypeIndex, 0, NumClumpTypes - 1);
    FClumpTypeData TypeData = GetClumpTypeData(ClumpTypeIndex);
    
    // World space clump center
    float2 ClumpCentreWorld = float2(
        ClumpCentre.x * HalfSize * 2.0 - HalfSize,
        ClumpCentre.y * HalfSize * 2.0 - HalfSize
    );
    
    // Pull to centre - 使用每种类型独立的参数
    float2 ToCentre = ClumpCentreWorld - Position.xy;
    Position.x += ToCentre.x * TypeData.PullToCentre;
    Position.y += ToCentre.y * TypeData.PullToCentre;
    
    // Random seeds for this instance
    float2 Seed1 = float2(x * 0.1 + 0.5, y * 0.1 + 0.7);
    float2 Seed2 = float2(x * 0.2 + 1.3, y * 0.2 + 2.1);
    float2 Seed3 = float2(x * 0.3 + 3.7, y * 0.3 + 4.9);
    float2 Seed4 = float2(x * 0.4 + 5.2, y * 0.4 + 6.8);
    
    // Grass blade properties with randomization - 使用每种类型独立的参数
    // 应用 Clump 级别的缩放
    float Height = (TypeData.BaseHeight + (Hash(Seed1) * 2.0 - 1.0) * TypeData.HeightRandom) * ClumpHeightScale;
    float Width = (TypeData.BaseWidth + (Hash(Seed2) * 2.0 - 1.0) * TypeData.WidthRandom) * ClumpWidthScale;
    float Tilt = TypeData.BaseTilt + (Hash(Seed3) * 2.0 - 1.0) * TypeData.TiltRandom;
    float Bend = TypeData.BaseBend + (Hash(Seed4) * 2.0 - 1.0) * TypeData.BendRandom;
    
    // Clamp values
    Height = max(Height, 1.0);
    Width = max(Width, 0.1);
    Tilt = saturate(Tilt);
    Bend = saturate(Bend);
    
    // Facing direction - 使用 ClumpBuffer 中预计算的 Clump 朝向和每种类型独立的一致性参数
    float2 IndividualDir = Random2D(float2(x * 0.15, y * 0.15));
    float IndividualDirLen = length(IndividualDir);
    if (IndividualDirLen > 0.001) IndividualDir = IndividualDir / IndividualDirLen;
    
    float2 FacingDir = lerp(IndividualDir, ClumpDirection, TypeData.PointInSameDirection);
    float FacingDirLen = length(FacingDir);
    if (FacingDirLen > 0.001) FacingDir = FacingDir / FacingDirLen;
    
    // Bezier control point offsets
    float P1Offset = Hash(Seed1 + float2(10.0, 20.0)) * 0.3;
    float P2Offset = Hash(Seed2 + float2(30.0, 40.0)) * 0.5;
    
    // Write outputs
    OutPositions[Index] = Position;
    OutGrassData0[Index] = float4(Height, Width, Tilt, Bend);
    OutGrassData1[Index] = float4(TaperAmount, FacingDir.x, FacingDir.y, P1Offset);
    OutGrassData2[Index] = P2Offset;
}