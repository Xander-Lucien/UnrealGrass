// CubicBezier.ush
// Cubic Bezier curve utilities for grass blade deformation

#pragma once

// Cubic Bezier curve point calculation
// B(t) = (1-t)^3*P0 + 3(1-t)^2*t*P1 + 3(1-t)*t^2*P2 + t^3*P3
float3 CubicBezier(float3 P0, float3 P1, float3 P2, float3 P3, float t)
{
    float t2 = t * t;
    float t3 = t2 * t;
    float mt = 1.0 - t;
    float mt2 = mt * mt;
    float mt3 = mt2 * mt;
    
    return mt3 * P0 + 3.0 * mt2 * t * P1 + 3.0 * mt * t2 * P2 + t3 * P3;
}

// Cubic Bezier tangent (derivative)
float3 CubicBezierTangent(float3 P0, float3 P1, float3 P2, float3 P3, float t)
{
    float t2 = t * t;
    float mt = 1.0 - t;
    float mt2 = mt * mt;
    
    return 3.0 * mt2 * (P1 - P0) + 6.0 * mt * t * (P2 - P1) + 3.0 * t2 * (P3 - P2);
}

// De Casteljau algorithm (alternative, good for subdivision)
float3 CubicBezierDeCasteljau(float3 P0, float3 P1, float3 P2, float3 P3, float t)
{
    float3 Q0 = lerp(P0, P1, t);
    float3 Q1 = lerp(P1, P2, t);
    float3 Q2 = lerp(P2, P3, t);
    float3 R0 = lerp(Q0, Q1, t);
    float3 R1 = lerp(Q1, Q2, t);
    return lerp(R0, R1, t);
}

// ============================================================================
// Grass Blade Deformation using Bezier Curve
// ============================================================================

// Grass blade vertex data structure (from compute shader output)
struct FGrassBladeData
{
    float Height;
    float Width;
    float Tilt;
    float Bend;
    float TaperAmount;
    float2 FacingDir;
    float P1Offset;
    float P2Offset;
};

// Deform a grass blade vertex using bezier curve
// Input:
//   LocalPos: Original vertex position (normalized, blade from 0 to 1 in Z)
//   BladeData: Per-instance blade properties
//   InstancePos: World position of blade root
// Output: Deformed world position
float3 DeformGrassBladeVertex(float3 LocalPos, FGrassBladeData BladeData, float3 InstancePos)
{
    // Normalized height along blade (0 = root, 1 = tip)
    float t = saturate(LocalPos.z);
    
    // Calculate width taper (narrower at top)
    float WidthScale = lerp(1.0, 1.0 - BladeData.TaperAmount, t);
    float FinalWidth = BladeData.Width * WidthScale;
    
    // Build bezier control points for blade curve
    // P0: Root (origin)
    // P1: First control point (slight offset based on tilt)
    // P2: Second control point (bend direction)
    // P3: Tip (top of blade with tilt offset)
    
    // Tilt direction in XY plane
    float2 TiltDir = BladeData.FacingDir;
    float TiltAmount = BladeData.Tilt * BladeData.Height;
    
    float3 P0 = float3(0, 0, 0);
    float3 P1 = float3(TiltDir.x * BladeData.P1Offset * TiltAmount, 
                       TiltDir.y * BladeData.P1Offset * TiltAmount, 
                       BladeData.Height * 0.33);
    float3 P2 = float3(TiltDir.x * BladeData.P2Offset * TiltAmount + TiltDir.x * BladeData.Bend * BladeData.Height * 0.5,
                       TiltDir.y * BladeData.P2Offset * TiltAmount + TiltDir.y * BladeData.Bend * BladeData.Height * 0.5,
                       BladeData.Height * 0.66);
    float3 P3 = float3(TiltDir.x * TiltAmount,
                       TiltDir.y * TiltAmount,
                       BladeData.Height);
    
    // Get position on bezier curve
    float3 CurvePos = CubicBezier(P0, P1, P2, P3, t);
    
    // Get tangent for width direction calculation
    float3 Tangent = CubicBezierTangent(P0, P1, P2, P3, t);
    float TangentLen = length(Tangent);
    if (TangentLen > 0.001)
    {
        Tangent = Tangent / TangentLen;
    }
    else
    {
        Tangent = float3(0, 0, 1);
    }
    
    // Calculate blade width direction (perpendicular to tangent and facing direction)
    float3 FacingDir3D = float3(BladeData.FacingDir.x, BladeData.FacingDir.y, 0);
    float3 WidthDir = cross(Tangent, FacingDir3D);
    float WidthDirLen = length(WidthDir);
    if (WidthDirLen > 0.001)
    {
        WidthDir = WidthDir / WidthDirLen;
    }
    else
    {
        WidthDir = float3(1, 0, 0);
    }
    
    // Apply width offset (LocalPos.x is the width offset in local space)
    float3 FinalPos = CurvePos + WidthDir * LocalPos.x * FinalWidth;
    
    // Transform to world space
    FinalPos += InstancePos;
    
    return FinalPos;
}

// Simplified version: Deform only position without tangent-based width
float3 DeformGrassBladeVertexSimple(float3 LocalPos, float Height, float Width, float Tilt, float Bend, float TaperAmount, float2 FacingDir, float3 InstancePos)
{
    float t = saturate(LocalPos.z);
    
    // Width taper
    float WidthScale = lerp(1.0, 1.0 - TaperAmount, t);
    float FinalWidth = Width * WidthScale;
    
    // Simple bezier-like curve
    float3 P0 = float3(0, 0, 0);
    float3 P3 = float3(FacingDir.x * Tilt * Height, FacingDir.y * Tilt * Height, Height);
    
    // Interpolate with bend
    float BendOffset = Bend * Height * t * (1.0 - t) * 4.0; // Parabolic bend
    float3 CurvePos = lerp(P0, P3, t);
    CurvePos.x += FacingDir.x * BendOffset;
    CurvePos.y += FacingDir.y * BendOffset;
    
    // Apply width
    float3 WidthDir = float3(-FacingDir.y, FacingDir.x, 0); // Perpendicular to facing
    float3 FinalPos = CurvePos + WidthDir * LocalPos.x * FinalWidth;
    
    FinalPos += InstancePos;
    
    return FinalPos;
}
