// GrassFrustumCulling.usf
// GPU Frustum Culling Compute Shader with LOD Support and Hi-Z Occlusion Culling

#include "/Engine/Private/Common.ush"

// ============================================================================
// Shader Parameters (bound from C++ SHADER_PARAMETER_STRUCT)
// ============================================================================

// Input: All instance positions
StructuredBuffer<float3> InPositions;

// Input: Grass blade data (Height, Width, Tilt, Bend)
StructuredBuffer<float4> InGrassData0;
// Input: Grass blade data (TaperAmount, FacingDir.x, FacingDir.y, P1Offset)
StructuredBuffer<float4> InGrassData1;
// Input: Grass blade data (P2Offset)
StructuredBuffer<float> InGrassData2;

// Output: Visible instance positions (LOD 0)
RWStructuredBuffer<float3> OutVisiblePositions;
// Output: Visible grass blade data (LOD 0)
RWStructuredBuffer<float4> OutVisibleGrassData0;
RWStructuredBuffer<float4> OutVisibleGrassData1;
RWStructuredBuffer<float> OutVisibleGrassData2;

// Output: Visible instance positions (LOD 1 独立 Buffer)
RWStructuredBuffer<float3> OutVisiblePositionsLOD1;
// Output: Visible grass blade data (LOD 1 独立 Buffer)
RWStructuredBuffer<float4> OutVisibleGrassData0LOD1;
RWStructuredBuffer<float4> OutVisibleGrassData1LOD1;
RWStructuredBuffer<float> OutVisibleGrassData2LOD1;

// Indirect Draw Args Buffer (LOD 0)
RWBuffer<uint> OutIndirectArgs;
// Indirect Draw Args Buffer (LOD 1)
RWBuffer<uint> OutIndirectArgsLOD1;

// Scalar parameters
uint TotalInstanceCount;
uint IndexCountPerInstance;      // LOD 0 索引数量 (39 for 15 vertices)
uint IndexCountPerInstanceLOD1;  // LOD 1 索引数量 (15 for 7 vertices)

// Frustum planes (6 planes: Left, Right, Bottom, Top, Near, Far)
float4 FrustumPlanes[6];

// Transform matrix
float4x4 LocalToWorld;

// Culling parameters
float BoundingRadius;
float MaxVisibleDistance;
float LOD0Distance;       // LOD 0 到 LOD 1 的切换距离 (<=0 表示禁用 LOD，所有草都用 LOD0)
float3 CameraPosition;

// ============================================================================
// Hi-Z Occlusion Culling Parameters
// ============================================================================
Texture2D<float> HiZTexture;
SamplerState HiZSampler;
uint bEnableOcclusionCulling;  // 是否启用遮挡剔除
float2 HiZSize;                // Hi-Z 纹理尺寸 (Mip 0)
float4x4 ViewProjectionMatrix; // 视图投影矩阵 (用于将世界坐标投影到屏幕空间)

// ============================================================================
// Hi-Z Occlusion Test Function
// 测试一个世界空间点是否被遮挡
// 返回 true 表示可见，false 表示被遮挡
// ============================================================================
bool IsVisibleHiZ(float3 WorldPos, float Radius)
{
    // 将世界坐标投影到裁剪空间
    float4 ClipPos = mul(float4(WorldPos, 1.0f), ViewProjectionMatrix);
    
    // 透视除法
    float3 NDC = ClipPos.xyz / ClipPos.w;
    
    // 检查是否在 NDC 范围外（已经被视锥剔除处理，这里做额外保护）
    if (any(abs(NDC.xy) > 1.0f) || NDC.z < 0.0f || NDC.z > 1.0f)
    {
        return true;  // 认为可见，让视锥剔除来处理
    }
    
    // NDC -> UV 空间 (Y 翻转)
    // NDC: X[-1,1] -> UV[0,1], Y[-1,1] -> UV[1,0]
    float2 ScreenUV = NDC.xy * float2(0.5f, -0.5f) + 0.5f;
    
    // 计算草叶在屏幕空间的大致像素覆盖范围
    // 根据距离和包围半径估算屏幕空间大小
    float ScreenRadius = Radius * HiZSize.x / (ClipPos.w * 2.0f);  // 粗略估算
    
    // 选择合适的 Mip 级别 (基于屏幕空间大小)
    // 每提升一级 Mip，覆盖范围翻倍
    float MipLevel = clamp(log2(max(ScreenRadius, 1.0f)), 0.0f, 7.0f);
    
    // 采样 Hi-Z 深度
    float HiZDepth = HiZTexture.SampleLevel(HiZSampler, ScreenUV, MipLevel).r;
    
    // 反向 Z: 物体深度 >= HiZ深度 则可见
    // 添加小偏移避免自遮挡问题
    float ObjectDepth = NDC.z;
    
    return ObjectDepth >= HiZDepth - 0.0001f;
}

// ============================================================================
// Main Culling Compute Shader with LOD
// ============================================================================

[numthreads(64, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint InstanceIndex = DispatchThreadId.x;
    
    // Bounds check
    if (InstanceIndex >= TotalInstanceCount)
    {
        return;
    }
    
    // Get instance local position
    float3 LocalPosition = InPositions[InstanceIndex];
    
    // Transform to world space
    float4 WorldPos4 = mul(float4(LocalPosition, 1.0f), LocalToWorld);
    float3 WorldPos = WorldPos4.xyz;
    
    // Calculate distance to camera
    float3 Delta = WorldPos - CameraPosition;
    float DistSq = dot(Delta, Delta);
    
    // Perform frustum culling - check if point is inside frustum
    bool bVisible = true;
    
    // Check against each frustum plane
    [unroll]
    for (int PlaneIndex = 0; PlaneIndex < 6; PlaneIndex++)
    {
        float PlaneDistance = dot(FrustumPlanes[PlaneIndex].xyz, WorldPos) + FrustumPlanes[PlaneIndex].w;

        if (PlaneDistance < -BoundingRadius)
        {
            bVisible = false;
            break;
        }
    }
    
    // Perform distance culling
    if (bVisible && MaxVisibleDistance > 0.0f)
    {
        float MaxDistSq = MaxVisibleDistance * MaxVisibleDistance;
        bVisible = (DistSq <= MaxDistSq);
    }
    
    // ========== Hi-Z Occlusion Culling ==========
    if (bVisible && bEnableOcclusionCulling > 0)
    {
        // 获取草叶高度用于计算包围盒顶部位置
        float4 GrassData = InGrassData0[InstanceIndex];
        float GrassHeight = GrassData.x;  // Height
        
        // 测试草叶根部和顶部两个点
        // 只要有一个点可见就认为整个草叶可见
        float3 WorldPosTop = WorldPos + float3(0, 0, GrassHeight);
        
        bool bRootVisible = IsVisibleHiZ(WorldPos, BoundingRadius);
        bool bTopVisible = IsVisibleHiZ(WorldPosTop, BoundingRadius);
        
        bVisible = bRootVisible || bTopVisible;
    }
    
    // If visible, determine LOD level and write to appropriate buffer
    if (bVisible)
    {
        // Determine LOD level based on distance
        // LOD0Distance <= 0 means LOD is disabled, all grass uses LOD0
        // Add small epsilon to avoid floating point precision issues at boundary
        float LOD0DistSq = LOD0Distance * LOD0Distance;
        bool bUseLOD0 = (LOD0Distance <= 0.0f) || (DistSq < LOD0DistSq + 1.0f);
        
        if (bUseLOD0)
        {
            // LOD 0: High quality (15 vertices)
            // Use atomic operation to get output index for LOD 0
            uint VisibleIndex = 0;
            InterlockedAdd(OutIndirectArgs[1], 1, VisibleIndex);
            
            // Write visible instance position (LOD 0 buffer)
            OutVisiblePositions[VisibleIndex] = LocalPosition;
            
            // Write visible instance grass data (LOD 0 buffers)
            OutVisibleGrassData0[VisibleIndex] = InGrassData0[InstanceIndex];
            OutVisibleGrassData1[VisibleIndex] = InGrassData1[InstanceIndex];
            OutVisibleGrassData2[VisibleIndex] = InGrassData2[InstanceIndex];
        }
        else
        {
            // LOD 1: Simplified (7 vertices)
            // Use atomic operation to get output index for LOD 1
            uint LOD1Index = 0;
            InterlockedAdd(OutIndirectArgsLOD1[1], 1, LOD1Index);
            
            // Write visible instance position to LOD 1 独立 buffer (从 index 0 开始)
            OutVisiblePositionsLOD1[LOD1Index] = LocalPosition;
            
            // Write visible instance grass data to LOD 1 独立 buffers
            OutVisibleGrassData0LOD1[LOD1Index] = InGrassData0[InstanceIndex];
            OutVisibleGrassData1LOD1[LOD1Index] = InGrassData1[InstanceIndex];
            OutVisibleGrassData2LOD1[LOD1Index] = InGrassData2[InstanceIndex];
        }
    }
}

// ============================================================================
// Reset Indirect Args Compute Shader (for both LOD 0 and LOD 1)
// ============================================================================

[numthreads(1, 1, 1)]
void ResetIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    // Reset Indirect Draw args for LOD 0
    // [0] = IndexCountPerInstance
    // [1] = InstanceCount (will be incremented by MainCS)
    // [2] = StartIndexLocation
    // [3] = BaseVertexLocation
    // [4] = StartInstanceLocation
    OutIndirectArgs[0] = IndexCountPerInstance;
    OutIndirectArgs[1] = 0;
    OutIndirectArgs[2] = 0;
    OutIndirectArgs[3] = 0;
    OutIndirectArgs[4] = 0;
    
    // Reset Indirect Draw args for LOD 1
    // LOD 1 使用独立的 buffer，StartInstanceLocation = 0
    OutIndirectArgsLOD1[0] = IndexCountPerInstanceLOD1;
    OutIndirectArgsLOD1[1] = 0;
    OutIndirectArgsLOD1[2] = 0;
    OutIndirectArgsLOD1[3] = 0;
    OutIndirectArgsLOD1[4] = 0;  // LOD 1 从 index 0 开始
}