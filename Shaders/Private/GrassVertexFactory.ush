// GrassVertexFactory.ush
// Grass Vertex Factory with Bezier Curve Blade Deformation

#include "/Engine/Private/VertexFactoryCommon.ush"

// ============================================================================
// Grass Instance Buffers (bound by FGrassVertexFactoryShaderParameters)
// ============================================================================
#if USE_GRASS_INSTANCING
StructuredBuffer<float3> GrassInstancePositions;
StructuredBuffer<float4> GrassData0;  // Height, Width, Tilt, Bend
StructuredBuffer<float4> GrassData1;  // TaperAmount, FacingDir.x, FacingDir.y, P1Offset
StructuredBuffer<float> GrassData2;   // P2Offset
#endif

// LOD 级别 (0 = LOD0 高质量, 1 = LOD1 简化版)
// 用于在 Pixel Shader 中区分 LOD 以便调试验证
uint GrassLODLevel;

// 弯曲法线程度 (0 = 平面法线, 1 = 完全弯曲)
// 用于让草叶边缘的法线向外弯曲，产生更柔和的光照效果
float GrassCurvedNormalAmount;

// 视角依赖旋转强度 (0 = 无旋转, 1 = 完全旋转朝向相机)
// 当从侧面观看草叶时，草叶会轻微旋转使其正面更多地朝向相机
// 这个技术来自《对马岛之魂》，可以让草地看起来更饱满
// 注意：值过大(>0.5)反而会让草地变薄，推荐值为 0.2 ~ 0.4
float GrassViewRotationAmount;

// ============================================================================
// Bezier Curve Functions
// ============================================================================
float3 CubicBezier(float3 P0, float3 P1, float3 P2, float3 P3, float t)
{
    float t2 = t * t;
    float t3 = t2 * t;
    float mt = 1.0 - t;
    float mt2 = mt * mt;
    float mt3 = mt2 * mt;
    return mt3 * P0 + 3.0 * mt2 * t * P1 + 3.0 * mt * t2 * P2 + t3 * P3;
}

float3 CubicBezierTangent(float3 P0, float3 P1, float3 P2, float3 P3, float t)
{
    float t2 = t * t;
    float mt = 1.0 - t;
    float mt2 = mt * mt;
    return 3.0 * mt2 * (P1 - P0) + 6.0 * mt * t * (P2 - P1) + 3.0 * t2 * (P3 - P2);
}

// ============================================================================
// 主输入结构
// ============================================================================
struct FVertexFactoryInput
{
    float4 Position : ATTRIBUTE0;
    half3 TangentX : ATTRIBUTE1;
    half4 TangentZ : ATTRIBUTE2;  // w = tangent basis determinant sign
    half4 Color : ATTRIBUTE3;
    
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 0
    float2 TexCoord0 : ATTRIBUTE4;
#endif

    VF_GPUSCENE_DECLARE_INPUT_BLOCK(13)
    VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
    VF_MOBILE_MULTI_VIEW_DECLARE_INPUT_BLOCK()
    
    uint VertexId : SV_VertexID;
    uint InstanceId : SV_InstanceID;
};

// ============================================================================
// Position Only 输入结构 (用于深度 Pass)
// ============================================================================
struct FPositionOnlyVertexFactoryInput
{
    float4 Position : ATTRIBUTE0;
    
    VF_GPUSCENE_DECLARE_INPUT_BLOCK(1)
    VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
    VF_MOBILE_MULTI_VIEW_DECLARE_INPUT_BLOCK()
    
    uint VertexId : SV_VertexID;
    uint InstanceId : SV_InstanceID;
};

// ============================================================================
// Position And Normal Only 输入结构 (用于阴影深度 Pass)
// ============================================================================
struct FPositionAndNormalOnlyVertexFactoryInput
{
    float4 Position : ATTRIBUTE0;
    float4 Normal : ATTRIBUTE2;
    
    VF_GPUSCENE_DECLARE_INPUT_BLOCK(1)
    VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
    VF_MOBILE_MULTI_VIEW_DECLARE_INPUT_BLOCK()
    
    uint VertexId : SV_VertexID;
    uint InstanceId : SV_InstanceID;
};

// ============================================================================
// VS -> PS 插值结构
// ============================================================================
struct FVertexFactoryInterpolantsVSToPS
{
    TANGENTTOWORLD_INTERPOLATOR_BLOCK
    
#if NUM_TEX_COORD_INTERPOLATORS
    float4 TexCoords[(NUM_TEX_COORD_INTERPOLATORS + 1) / 2] : PACKED_TEXCOORDS;
#endif

    float4 Color : TEXCOORD3;
    
    // LOD 级别
    nointerpolation float LODLevel : TEXCOORD4;
    
#if INSTANCED_STEREO
    nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
#endif

#if VF_USE_PRIMITIVE_SCENE_DATA
    nointerpolation uint PrimitiveId : PRIMITIVE_ID;
#endif
};

// ============================================================================
// 中间数据结构 - 增加草叶变形相关数据
// ============================================================================
struct FVertexFactoryIntermediates
{
    float4 Color;
    FSceneDataIntermediates SceneData;
    float3x3 TangentToLocal;
    float3x3 TangentToWorld;
    
    // 草叶变形后的切线空间
    float3 DeformedNormal;
    float3 DeformedTangent;
    float3 DeformedBitangent;
    
    // 原始UV
    float2 TexCoord0;
};

FPrimitiveSceneData GetPrimitiveData(FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.SceneData.Primitive;
}

// ============================================================================
// Helper Functions
// ============================================================================

// 草叶变形结果结构
struct FGrassDeformResult
{
    float3 Position;
    float3 Normal;
    float3 Tangent;
    float3 Bitangent;
};

// 应用弯曲法线效果
// WidthRatio: 归一化的左右位置 (0 = 左边缘, 0.5 = 中心, 1 = 右边缘)
// BladeNormal: 原始的草叶法线
// WidthDir: 草叶宽度方向
float3 ApplyCurvedNormal(float3 BladeNormal, float3 WidthDir, float WidthRatio, float CurvedAmount)
{
    // 将 WidthRatio 从 [0, 1] 转换到 [-1, 1]
    // 左边缘 -> -1, 中心 -> 0, 右边缘 -> +1
    float NormalizedWidth = (WidthRatio - 0.5) * 2.0;
    
    // 弯曲程度: 边缘处弯曲最大，中心不弯曲
    // 使用 sin 函数产生平滑的弯曲过渡
    float CurveFactor = NormalizedWidth * CurvedAmount;
    
    // 将法线向宽度方向弯曲
    // 左边缘的法线向左弯，右边缘的法线向右弯
    float3 CurvedNormal = normalize(BladeNormal + WidthDir * CurveFactor);
    
    return CurvedNormal;
}

// Get grass instance data and deform vertex position with normal calculation
FGrassDeformResult GetDeformedGrassPositionAndNormal(float3 LocalPos, uint InstanceId, half4 VertexColor)
{
    FGrassDeformResult Result;
    Result.Position = LocalPos;
    Result.Normal = float3(0, 1, 0);  // 默认法线朝Y轴
    Result.Tangent = float3(1, 0, 0);
    Result.Bitangent = float3(0, 0, 1);
    
    // 从顶点颜色获取左右侧信息
    // G 通道: 0 = 左侧, 1 = 右侧
    float VertexWidthRatio = VertexColor.g;
#if USE_GRASS_INSTANCING
    // Get instance data
    float3 InstancePos = GrassInstancePositions[InstanceId];
    float4 Data0 = GrassData0[InstanceId];  // Height, Width, Tilt, Bend
    float4 Data1 = GrassData1[InstanceId];  // TaperAmount, FacingDir.x, FacingDir.y, P1Offset
    float P2Offset = GrassData2[InstanceId];
    
    float Height = Data0.x;
    float Width = Data0.y;
    float Tilt = Data0.z;
    float Bend = Data0.w;
    float TaperAmount = Data1.x;
    float2 FacingDir = float2(Data1.y, Data1.z);
    float P1Offset = Data1.w;
    
    // Normalized height along blade (0 = root, 1 = tip)
    float DefaultBladeHeight = 70.819;
    float t = saturate(LocalPos.z / DefaultBladeHeight);
    
    // Width taper (narrower at top)
    float WidthScale = lerp(1.0, 1.0 - TaperAmount, t);
    float FinalWidth = Width * WidthScale;
    float OriginalWidth = 3.445;
    float WidthRatioScale = FinalWidth / (OriginalWidth * 2.0);
    
    // Build bezier control points
    float TiltAmount = Tilt * Height;
    
    float3 P0 = float3(0, 0, 0);
    float3 P1 = float3(FacingDir.x * P1Offset * TiltAmount, 
                       FacingDir.y * P1Offset * TiltAmount, 
                       Height * 0.33);
    float3 P2 = float3(FacingDir.x * P2Offset * TiltAmount + FacingDir.x * Bend * Height * 0.5,
                       FacingDir.y * P2Offset * TiltAmount + FacingDir.y * Bend * Height * 0.5,
                       Height * 0.66);
    float3 P3 = float3(FacingDir.x * TiltAmount,
                       FacingDir.y * TiltAmount,
                       Height);
    
    // Get position on bezier curve
    float3 CurvePos = CubicBezier(P0, P1, P2, P3, t);
    
    // Get tangent (up direction along blade)
    float3 UpTangent = CubicBezierTangent(P0, P1, P2, P3, t);
    float UpTangentLen = length(UpTangent);
    if (UpTangentLen > 0.001)
    {
        UpTangent = UpTangent / UpTangentLen;
    }
    else
    {
        UpTangent = float3(0, 0, 1);
    }
    
    // ========== 视角依赖旋转 (Ghost of Tsushima 风格) ==========
    // 当从侧面观看草叶时，让草叶轻微旋转朝向相机，使草地看起来更饱满
    float2 AdjustedFacingDir = FacingDir;
    
    // 计算从草叶位置指向相机的方向 (在世界空间 XY 平面上)
    float3 WorldPos = InstancePos + CurvePos; // 草叶当前位置的近似值
    // 注意: ResolvedView.WorldCameraOrigin 是 FDFVector3 类型 (双精度)
    // 使用 DFHackToFloat 将其转换为 float3
    float3 CameraWorldPos = DFHackToFloat(ResolvedView.WorldCameraOrigin);
    float3 ToCamera = CameraWorldPos - WorldPos;
    float2 ToCameraXY = normalize(ToCamera.xy);
    
    // 计算草叶朝向与相机方向的点积
    // 当点积接近 0 时，说明相机在草叶的侧面
    float DotWithCamera = dot(FacingDir, ToCameraXY);
    
    // 计算需要旋转的方向
    // 叉积的符号决定了应该向哪个方向旋转
    float CrossSign = sign(FacingDir.x * ToCameraXY.y - FacingDir.y * ToCameraXY.x);
    
    // 计算旋转量：当从侧面观看时旋转最大，正面或背面观看时不旋转
    // 使用 1 - abs(DotWithCamera) 来获取侧面程度
    float SideFactor = 1.0 - abs(DotWithCamera);
    float RotationAmount = SideFactor * GrassViewRotationAmount * CrossSign;
    
    // 使用 2D 旋转矩阵旋转朝向
    // 旋转角度较小时可以用近似: cos(a) ≈ 1, sin(a) ≈ a
    // 但为了更准确，我们使用实际的旋转
    float RotAngle = RotationAmount * 0.5; // 最大旋转约 28 度 (0.5 弧度)
    float CosRot = cos(RotAngle);
    float SinRot = sin(RotAngle);
    AdjustedFacingDir.x = FacingDir.x * CosRot - FacingDir.y * SinRot;
    AdjustedFacingDir.y = FacingDir.x * SinRot + FacingDir.y * CosRot;
    AdjustedFacingDir = normalize(AdjustedFacingDir);
    
    // Width direction (perpendicular to adjusted facing direction in XY plane)
    float3 WidthDir = float3(-AdjustedFacingDir.y, AdjustedFacingDir.x, 0);
    float WidthDirLen = length(WidthDir);
    if (WidthDirLen > 0.001)
    {
        WidthDir = WidthDir / WidthDirLen;
    }
    else
    {
        WidthDir = float3(1, 0, 0);
    }
    
    // Calculate normal: perpendicular to both width direction and up tangent
    // Normal points away from the blade surface (front face)
    // 使用调整后的朝向来计算法线
    float3 BladeNormal = cross(WidthDir, UpTangent);
    float NormalLen = length(BladeNormal);
    if (NormalLen > 0.001)
    {
        BladeNormal = BladeNormal / NormalLen;
    }
    else
    {
        // Fallback: use adjusted facing direction as normal
        BladeNormal = float3(AdjustedFacingDir.x, AdjustedFacingDir.y, 0);
    }
    
    // 应用弯曲法线效果
    // 使用顶点颜色的 G 通道 (VertexWidthRatio) 来确定弯曲方向
    BladeNormal = ApplyCurvedNormal(BladeNormal, WidthDir, VertexWidthRatio, GrassCurvedNormalAmount);
    
    // Apply width offset (LocalPos.x is the width offset)
    float3 FinalPos = CurvePos + WidthDir * LocalPos.x * WidthRatioScale;
    
    // Add instance position
    FinalPos += InstancePos;
    
    Result.Position = FinalPos;
    Result.Normal = BladeNormal;
    Result.Tangent = WidthDir;      // Tangent along width (U direction)
    Result.Bitangent = UpTangent;   // Bitangent along height (V direction)
#endif
    
    return Result;
}

// Simple offset-only version for depth passes
float3 GetGrassInstanceOffset(uint InstanceId)
{
#if USE_GRASS_INSTANCING
    return GrassInstancePositions[InstanceId];
#else
    return float3(0, 0, 0);
#endif
}

// Calculate tangent basis
float3x3 CalcTangentBasis(half3 TangentX, half4 TangentZ)
{
    half3 TangentXN = TangentBias(TangentX);
    half4 TangentZN = TangentBias(TangentZ);
    half3 TangentY = cross(TangentZN.xyz, TangentXN) * TangentZN.w;
    return float3x3(TangentXN, TangentY, TangentZN.xyz);
}

// ============================================================================
// Vertex Factory 核心函数
// ============================================================================

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
    FVertexFactoryIntermediates Intermediates;
    Intermediates.SceneData = VF_GPUSCENE_GET_INTERMEDIATES(Input);
    Intermediates.Color = Input.Color FCOLOR_COMPONENT_SWIZZLE;
    
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 0
    Intermediates.TexCoord0 = Input.TexCoord0;
#else
    Intermediates.TexCoord0 = float2(0, 0);
#endif
    
#if USE_GRASS_INSTANCING
    // 计算变形后的位置和法线
    FGrassDeformResult DeformResult = GetDeformedGrassPositionAndNormal(Input.Position.xyz, Input.InstanceId, Input.Color);
    
    // 使用变形后的切线空间
    Intermediates.DeformedNormal = DeformResult.Normal;
    Intermediates.DeformedTangent = DeformResult.Tangent;
    Intermediates.DeformedBitangent = DeformResult.Bitangent;
    
    // 构建 TangentToLocal 矩阵 (行向量: Tangent, Bitangent, Normal)
    Intermediates.TangentToLocal = float3x3(
        DeformResult.Tangent,
        DeformResult.Bitangent,
        DeformResult.Normal
    );
#else
    Intermediates.TangentToLocal = CalcTangentBasis(Input.TangentX, Input.TangentZ);
    Intermediates.DeformedNormal = Intermediates.TangentToLocal[2];
    Intermediates.DeformedTangent = Intermediates.TangentToLocal[0];
    Intermediates.DeformedBitangent = Intermediates.TangentToLocal[1];
#endif
    
    // 转换到世界空间
    Intermediates.TangentToWorld = mul(Intermediates.TangentToLocal, GetLocalToWorld3x3());
    
    return Intermediates;
}

// Main World Position calculation (with Bezier deformation)
float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    FDFMatrix LocalToWorld = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    
#if USE_GRASS_INSTANCING
    // Apply Bezier curve deformation
    FGrassDeformResult DeformResult = GetDeformedGrassPositionAndNormal(Input.Position.xyz, Input.InstanceId, Input.Color);
    float4 WorldPos = TransformLocalToTranslatedWorld(DeformResult.Position, LocalToWorld);
#else
    float4 WorldPos = TransformLocalToTranslatedWorld(Input.Position.xyz, LocalToWorld);
#endif
    
    return WorldPos;
}

// Position Only version (for depth pass)
float4 VertexFactoryGetWorldPosition(FPositionOnlyVertexFactoryInput Input)
{
    FDFMatrix LocalToWorld = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    
#if USE_GRASS_INSTANCING
    // 深度 pass 不需要弯曲法线，使用默认的中心值 (0.5)
    half4 DefaultColor = half4(0, 0.5, 1, 1);  // G = 0.5 表示中心，不弯曲
    FGrassDeformResult DeformResult = GetDeformedGrassPositionAndNormal(Input.Position.xyz, Input.InstanceId, DefaultColor);
    float4 WorldPos = TransformLocalToTranslatedWorld(DeformResult.Position, LocalToWorld);
#else
    float4 WorldPos = TransformLocalToTranslatedWorld(Input.Position.xyz, LocalToWorld);
#endif
    
    return WorldPos;
}

// Position And Normal Only version (for shadow depth pass)
float4 VertexFactoryGetWorldPosition(FPositionAndNormalOnlyVertexFactoryInput Input)
{
    FDFMatrix LocalToWorld = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    
#if USE_GRASS_INSTANCING
    // 阴影深度 pass 不需要弯曲法线，使用默认的中心值 (0.5)
    half4 DefaultColor = half4(0, 0.5, 1, 1);  // G = 0.5 表示中心，不弯曲
    FGrassDeformResult DeformResult = GetDeformedGrassPositionAndNormal(Input.Position.xyz, Input.InstanceId, DefaultColor);
    float4 WorldPos = TransformLocalToTranslatedWorld(DeformResult.Position, LocalToWorld);
#else
    float4 WorldPos = TransformLocalToTranslatedWorld(Input.Position.xyz, LocalToWorld);
#endif
    
    return WorldPos;
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    // 使用变形后的法线，转换到世界空间
    return normalize(mul(Intermediates.DeformedNormal, GetLocalToWorld3x3()));
}

float3 VertexFactoryGetWorldNormal(FPositionAndNormalOnlyVertexFactoryInput Input)
{
    FDFMatrix LocalToWorld = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    float3 InvScale = GetPrimitiveDataFromUniformBuffer().InvNonUniformScale;
    
#if USE_GRASS_INSTANCING
    // 阴影 pass 不需要弯曲法线，使用默认的中心值 (0.5)
    half4 DefaultColor = half4(0, 0.5, 1, 1);  // G = 0.5 表示中心，不弯曲
    FGrassDeformResult DeformResult = GetDeformedGrassPositionAndNormal(Input.Position.xyz, Input.InstanceId, DefaultColor);
    return RotateLocalToWorld(DeformResult.Normal, LocalToWorld, InvScale);
#else
    return RotateLocalToWorld(Input.Normal.xyz, LocalToWorld, InvScale);
#endif
}

float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
{
    return InWorldPosition;
}

float3 VertexFactoryGetPositionForVertexLighting(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 TranslatedWorldPosition)
{
    return TranslatedWorldPosition;
}

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    // 草地不需要运动模糊，返回当前位置
    return VertexFactoryGetWorldPosition(Input, Intermediates);
}

float3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.TangentToLocal;
}

// ============================================================================
// 材质参数
// ============================================================================

FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
    FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();
    
#if NUM_TEX_COORD_INTERPOLATORS
    UNROLL
    for (int UVIndex = 0; UVIndex < NUM_TEX_COORD_INTERPOLATORS / 2; ++UVIndex)
    {
        Result.TexCoords[(UVIndex * 2) + 0] = Interpolants.TexCoords[UVIndex].xy;
        Result.TexCoords[(UVIndex * 2) + 1] = Interpolants.TexCoords[UVIndex].zw;
    }
    #if (NUM_TEX_COORD_INTERPOLATORS & 1) == 1
        Result.TexCoords[NUM_TEX_COORD_INTERPOLATORS - 1] = Interpolants.TexCoords[NUM_TEX_COORD_INTERPOLATORS / 2].xy;
    #endif
#endif

    Result.VertexColor = Interpolants.Color;
    
    half3 TangentToWorld0 = Interpolants.TangentToWorld0.xyz;
    half4 TangentToWorld2 = Interpolants.TangentToWorld2;
    Result.TangentToWorld = AssembleTangentToWorld(TangentToWorld0, TangentToWorld2);
    Result.UnMirrored = TangentToWorld2.w;
    Result.TwoSidedSign = 1;
    
    return Result;
}

// 5参数版本 (引擎期望的签名)
FMaterialVertexParameters GetMaterialVertexParameters(
    FVertexFactoryInput Input,
    FVertexFactoryIntermediates Intermediates,
    float3 WorldPosition,
    float3x3 TangentToLocal,
    bool bIsPreviousFrame = false)
{
    FMaterialVertexParameters Result = MakeInitializedMaterialVertexParameters();
    Result.SceneData = Intermediates.SceneData;
    Result.WorldPosition = WorldPosition;
    Result.VertexColor = Intermediates.Color;
    Result.TangentToWorld = Intermediates.TangentToWorld;
    Result.PreSkinnedPosition = Input.Position.xyz;
    Result.PreSkinnedNormal = Intermediates.DeformedNormal;
    
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 0
    Result.TexCoords[0] = Intermediates.TexCoord0;
#endif

#if ENABLE_NEW_HLSL_GENERATOR
    EvaluateVertexMaterialAttributes(Result);
#endif
    Result.LWCData = MakeMaterialLWCData(Result);
    
    return Result;
}

// ============================================================================
// 插值数据
// ============================================================================

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
    FVertexFactoryInterpolantsVSToPS Interpolants;
    
#if NUM_TEX_COORD_INTERPOLATORS
    float2 CustomizedUVs[NUM_TEX_COORD_INTERPOLATORS];
    GetMaterialCustomizedUVs(VertexParameters, CustomizedUVs);
    GetCustomInterpolators(VertexParameters, CustomizedUVs);
    
    UNROLL
    for (int UVIndex = 0; UVIndex < NUM_TEX_COORD_INTERPOLATORS / 2; ++UVIndex)
    {
        Interpolants.TexCoords[UVIndex].xy = CustomizedUVs[UVIndex * 2 + 0];
        Interpolants.TexCoords[UVIndex].zw = CustomizedUVs[UVIndex * 2 + 1];
    }
    #if (NUM_TEX_COORD_INTERPOLATORS & 1) == 1
        Interpolants.TexCoords[NUM_TEX_COORD_INTERPOLATORS / 2].xy = CustomizedUVs[NUM_TEX_COORD_INTERPOLATORS - 1];
        Interpolants.TexCoords[NUM_TEX_COORD_INTERPOLATORS / 2].zw = 0.0f;
    #endif
#endif

    Interpolants.Color = Intermediates.Color;
    
    // 传递 LOD 级别到 Pixel Shader
    Interpolants.LODLevel = (float)GrassLODLevel;
    
    // 传递切线空间到世界空间的变换
    // TangentToWorld0 = Tangent (X axis of tangent space in world)
    // TangentToWorld2 = Normal (Z axis of tangent space in world), w = determinant sign
    Interpolants.TangentToWorld0.xyz = Intermediates.TangentToWorld[0];
    Interpolants.TangentToWorld0.w = 0;
    Interpolants.TangentToWorld2 = float4(Intermediates.TangentToWorld[2], sign(determinant(Intermediates.TangentToLocal)));
    
#if INSTANCED_STEREO
    Interpolants.EyeIndex = GetEyeIndexFromVF(Input);
#endif

#if VF_USE_PRIMITIVE_SCENE_DATA
    Interpolants.PrimitiveId = Intermediates.SceneData.PrimitiveId;
#endif
    
    return Interpolants;
}

// ============================================================================
// 其他必需接口
// ============================================================================

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return 0;
}

uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
#if VF_USE_PRIMITIVE_SCENE_DATA
    return Interpolants.PrimitiveId;
#else
    return 0;
#endif
}

#if VF_USE_PRIMITIVE_SCENE_DATA
void SetPrimitiveId(inout FVertexFactoryInterpolantsVSToPS Interpolants, uint PrimitiveId)
{
    Interpolants.PrimitiveId = PrimitiveId;
}
#endif

// Include 默认接口实现
#include "/Engine/Private/VertexFactoryDefaultInterface.ush"