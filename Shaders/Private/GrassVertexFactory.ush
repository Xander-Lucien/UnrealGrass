// GrassVertexFactory.ush
// Grass Vertex Factory with Bezier Curve Blade Deformation

#include "/Engine/Private/VertexFactoryCommon.ush"

// ============================================================================
// Grass Instance Buffers (bound by FGrassVertexFactoryShaderParameters)
// ============================================================================
#if USE_GRASS_INSTANCING
StructuredBuffer<float3> GrassInstancePositions;
StructuredBuffer<float4> GrassData0;  // Height, Width, Tilt, Bend
StructuredBuffer<float4> GrassData1;  // TaperAmount, FacingDir.x, FacingDir.y, P1Offset
StructuredBuffer<float> GrassData2;   // P2Offset
#endif

// LOD 级别 (0 = LOD0 高质量, 1 = LOD1 简化版)
// 用于在 Pixel Shader 中区分 LOD 以便调试验证
uint GrassLODLevel;


float GrassCurvedNormalAmount;// 弯曲法线程度 (0 = 平面法线, 1 = 完全弯曲)

float GrassViewRotationAmount;// 视角依赖旋转强度 (0 = 无旋转, 1 = 完全旋转朝向相机)

float3 GrassWindDirection;
float GrassWindStrength;
Texture2D GrassWindNoiseTexture;
SamplerState GrassWindNoiseSampler;
float2 GrassWindNoiseScale;
float GrassWindNoiseStrength;
float GrassWindNoiseSpeed;

// 风波动参数
float GrassWindWaveSpeed;       // 波动速度 (小幅抖动的频率)
float GrassWindWaveAmplitude;   // 波动振幅 (小幅抖动的大小，叠加在持续偏移之上)
float GrassWindSinOffsetRange;  // 正弦偏移范围 (每个草叶的相位差)
float GrassWindPushTipForward;  // 尖端前推量 (草叶顶端额外沿风向前倾)

// 局部风方向旋转参数 (对马岛之魂风格)
// Noise 纹理被映射为一个局部风方向角度，投影到草叶侧面方向上，旋转草叶朝向
// 这使得每棵草在风中的倾倒方向不同，而不是所有草都沿同一个风向倒
float GrassLocalWindRotateAmount;  // 局部风方向旋转强度 (0 = 无旋转, 1 = 最大旋转)



// ============================================================================
// Bezier Curve Functions
// ============================================================================
float3 CubicBezier(float3 P0, float3 P1, float3 P2, float3 P3, float t)
{
    float t2 = t * t;
    float t3 = t2 * t;
    float mt = 1.0 - t;
    float mt2 = mt * mt;
    float mt3 = mt2 * mt;
    return mt3 * P0 + 3.0 * mt2 * t * P1 + 3.0 * mt * t2 * P2 + t3 * P3;
}

float3 CubicBezierTangent(float3 P0, float3 P1, float3 P2, float3 P3, float t)
{
    float t2 = t * t;
    float mt = 1.0 - t;
    float mt2 = mt * mt;
    return 3.0 * mt2 * (P1 - P0) + 6.0 * mt * t * (P2 - P1) + 3.0 * t2 * (P3 - P2);
}

// ============================================================================
// 主输入结构
// ============================================================================
struct FVertexFactoryInput
{
    float4 Position : ATTRIBUTE0;
    half3 TangentX : ATTRIBUTE1;
    half4 TangentZ : ATTRIBUTE2;  // w = tangent basis determinant sign
    half4 Color : ATTRIBUTE3;
    
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 0
    float2 TexCoord0 : ATTRIBUTE4;
#endif

    VF_GPUSCENE_DECLARE_INPUT_BLOCK(13)
    VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
    VF_MOBILE_MULTI_VIEW_DECLARE_INPUT_BLOCK()
    
    uint VertexId : SV_VertexID;
    uint InstanceId : SV_InstanceID;
};

// ============================================================================
// Position Only 输入结构 (用于深度 Pass)
// ============================================================================
struct FPositionOnlyVertexFactoryInput
{
    float4 Position : ATTRIBUTE0;
    
    VF_GPUSCENE_DECLARE_INPUT_BLOCK(1)
    VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
    VF_MOBILE_MULTI_VIEW_DECLARE_INPUT_BLOCK()
    
    uint VertexId : SV_VertexID;
    uint InstanceId : SV_InstanceID;
};

// ============================================================================
// Position And Normal Only 输入结构 (用于阴影深度 Pass)
// ============================================================================
struct FPositionAndNormalOnlyVertexFactoryInput
{
    float4 Position : ATTRIBUTE0;
    float4 Normal : ATTRIBUTE2;
    
    VF_GPUSCENE_DECLARE_INPUT_BLOCK(1)
    VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
    VF_MOBILE_MULTI_VIEW_DECLARE_INPUT_BLOCK()
    
    uint VertexId : SV_VertexID;
    uint InstanceId : SV_InstanceID;
};

// ============================================================================
// VS -> PS 插值结构
// ============================================================================
struct FVertexFactoryInterpolantsVSToPS
{
    TANGENTTOWORLD_INTERPOLATOR_BLOCK
    
#if NUM_TEX_COORD_INTERPOLATORS
    float4 TexCoords[(NUM_TEX_COORD_INTERPOLATORS + 1) / 2] : PACKED_TEXCOORDS;
#endif

    float4 Color : TEXCOORD3;
    
    // LOD 级别
    nointerpolation float LODLevel : TEXCOORD4;
    
#if INSTANCED_STEREO
    nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
#endif

#if VF_USE_PRIMITIVE_SCENE_DATA
    nointerpolation uint PrimitiveId : PRIMITIVE_ID;
#endif
};

// ============================================================================
// 中间数据结构 - 增加草叶变形相关数据
// ============================================================================
struct FVertexFactoryIntermediates
{
    float4 Color;
    FSceneDataIntermediates SceneData;
    float3x3 TangentToLocal;
    float3x3 TangentToWorld;
    
    // 草叶变形后的切线空间
    float3 DeformedNormal;
    float3 DeformedTangent;
    float3 DeformedBitangent;
    
    // 原始UV
    float2 TexCoord0;
};

FPrimitiveSceneData GetPrimitiveData(FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.SceneData.Primitive;
}

// ============================================================================
// Helper Functions
// ============================================================================
// 草叶变形结果结构
struct FGrassDeformResult
{
    float3 Position;
    float3 Normal;
    float3 Tangent;
    float3 Bitangent;
};

// 应用弯曲法线效果
// WidthRatio: 归一化的左右位置 (0 = 左边缘, 0.5 = 中心, 1 = 右边缘)
// BladeNormal: 原始的草叶法线
// WidthDir: 草叶宽度方向
float3 ApplyCurvedNormal(float3 BladeNormal, float3 WidthDir, float WidthRatio, float CurvedAmount)
{
    // 将 WidthRatio 从 [0, 1] 转换到 [-1, 1]
    // 左边缘 -> -1, 中心 -> 0, 右边缘 -> +1
    float NormalizedWidth = (WidthRatio - 0.5) * 2.0;
    
    // 弯曲程度: 边缘处弯曲最大，中心不弯曲
    // 使用 sin 函数产生平滑的弯曲过渡
    float CurveFactor = NormalizedWidth * CurvedAmount;
    
    // 将法线向宽度方向弯曲
    // 左边缘的法线向左弯，右边缘的法线向右弯
    float3 CurvedNormal = normalize(BladeNormal + WidthDir * CurveFactor);
    
    return CurvedNormal;
}

// Get grass instance data and deform vertex position with normal calculation
FGrassDeformResult GetDeformedGrassPositionAndNormal(float3 LocalPos, uint InstanceId, half4 VertexColor)
{
    FGrassDeformResult Result;
    Result.Position = LocalPos;
    Result.Normal = float3(0, 1, 0);  // 默认法线朝Y轴
    Result.Tangent = float3(1, 0, 0);
    Result.Bitangent = float3(0, 0, 1);
    
    // 从顶点颜色获取左右侧信息
    // G 通道: 0 = 左侧, 1 = 右侧
    float VertexWidthRatio = VertexColor.g;
#if USE_GRASS_INSTANCING
    // Get instance data
    float3 InstancePos = GrassInstancePositions[InstanceId];
    float4 Data0 = GrassData0[InstanceId];  // Height, Width, Tilt, Bend
    float4 Data1 = GrassData1[InstanceId];  // TaperAmount, FacingDir.x, FacingDir.y, P1Offset
    float P2Offset = GrassData2[InstanceId];
    
    float Height = Data0.x;
    float Width = Data0.y;
    float Tilt = Data0.z;
    float Bend = Data0.w;
    float TaperAmount = Data1.x;
    float2 FacingDir = float2(Data1.y, Data1.z);
    float P1Offset = Data1.w;
    
    // Normalized height along blade (0 = root, 1 = tip)
    float DefaultBladeHeight = 70.819;
    float t = saturate(LocalPos.z / DefaultBladeHeight);
    
    // Width taper (narrower at top)
    float WidthScale = lerp(1.0, 1.0 - TaperAmount, t);
    float FinalWidth = Width * WidthScale;
    float OriginalWidth = 3.445;
    float WidthRatioScale = FinalWidth / (OriginalWidth * 2.0);
    
    // ========== 构建贝塞尔控制点 (《对马岛之魂》风格) ==========
    // 先计算 P3 (草叶尖端)，然后通过 lerp 计算 P1、P2 的基础位置
    // 风力只作用于 P2 和 P3，这样草叶在大风时保持贝塞尔曲线的弯曲形态
    // 而不会因为每个控制点独立的正弦相位而变成正弦波形状
    
    float TiltAmount = Tilt * Height;
    
    float3 P0 = float3(0, 0, 0);
    float3 P3 = float3(FacingDir.x * TiltAmount,
                       FacingDir.y * TiltAmount,
                       Height);
    
    // P1、P2 通过 lerp 从 P0 到 P3 之间均匀插值得到基础位置
    float3 P1 = lerp(P0, P3, 0.33);
    float3 P2 = lerp(P0, P3, 0.66);
    
    // 计算草叶的倾斜方向 (从 P0 到 P3)
    float3 bladeDir = normalize(P3 - P0);
    
    // 计算贝塞尔控制点的偏移方向 (垂直于草叶倾斜方向)
    // 这使得弯曲和风效果是侧向摆动而不是前后拉伸
    float3 bezCtrlOffsetDir = normalize(cross(bladeDir, float3(0, 0, 1)));
    
    // P1、P2 受 bend (静态弯曲) 影响
    P1 += bezCtrlOffsetDir * Bend * P1Offset;
    P2 += bezCtrlOffsetDir * Bend * P2Offset;
    
    // ========== 风效果 (持续偏移 + 小幅波动 + 局部风方向旋转) ==========
    // 核心思路:
    // 1. 风力直接沿风向把草叶压弯 (持续偏移)
    // 2. 叠加一个小幅 sin 波动产生呼吸感
    // 3. 用 Noise 纹理生成局部风方向，旋转草叶朝向 (对马岛之魂风格)
    
    // 每棵草的随机相位 (让波动不同步)
    float hash = frac(sin(dot(InstancePos.xy, float2(12.9898, 78.233))) * 43758.5453);
    
    // 风向 (XY 平面上的单位向量)
    float2 WindDir2D = GrassWindDirection.xy;
    float WindDirLen = length(WindDir2D);
    float2 BaseWindDir = WindDirLen > 0.001 ? (WindDir2D / WindDirLen) : float2(1.0, 0.0);
    float3 WindDir3D = float3(BaseWindDir.x, BaseWindDir.y, 0.0);
    
    // Noise 贴图采样 - 产生空间变化的风力扰动
    float2 NoiseUV = InstancePos.xy * GrassWindNoiseScale + ResolvedView.RealTime.x * GrassWindNoiseSpeed;
    float NoiseValue = GrassWindNoiseTexture.SampleLevel(GrassWindNoiseSampler, NoiseUV, 0).r;
    float NoiseSigned = (NoiseValue * 2.0 - 1.0) * GrassWindNoiseStrength;
    
    // ========== 局部风方向旋转 (对马岛之魂风格) ==========
    // 将 Noise 值映射为一个角度 (-π ~ π)，变成一个 2D 方向
    // 这样每个空间位置的风方向都不同，草叶倾倒方向会有自然的变化
    float localWindTheta = ((NoiseValue * 2.0) - 1.0) * 3.14159;
    float2 localWindDir = float2(cos(localWindTheta), sin(localWindTheta));
    
    // 计算草叶的侧面方向 (垂直于朝向)
    float2 grassSideVec = normalize(float2(-FacingDir.y, FacingDir.x));
    
    // 将局部风方向投影到草叶侧面方向上
    // 当风垂直于草叶朝向时旋转最大，平行时不旋转
    float rotateBladeFromLocalWind = dot(grassSideVec, localWindDir);
    
    // 计算最终旋转角度 (最大旋转 π/2 弧度 = 90°，受强度参数控制)
    float localWindRotateAngle = rotateBladeFromLocalWind * (3.14159 / 2.0) * GrassLocalWindRotateAmount;
    
    // 将旋转应用到 FacingDir 上
    float localWindCos = cos(localWindRotateAngle);
    float localWindSin = sin(localWindRotateAngle);
    FacingDir = float2(
        FacingDir.x * localWindCos - FacingDir.y * localWindSin,
        FacingDir.x * localWindSin + FacingDir.y * localWindCos
    );
    FacingDir = normalize(FacingDir);
    
    // 旋转后需要重新计算倾斜方向和 bezCtrlOffsetDir
    P3 = float3(FacingDir.x * TiltAmount,
                FacingDir.y * TiltAmount,
                Height);
    P1 = lerp(P0, P3, 0.33);
    P2 = lerp(P0, P3, 0.66);
    bladeDir = normalize(P3 - P0);
    bezCtrlOffsetDir = normalize(cross(bladeDir, float3(0, 0, 1)));
    P1 += bezCtrlOffsetDir * Bend * P1Offset;
    P2 += bezCtrlOffsetDir * Bend * P2Offset;
    
    // 风力 = 基础风强 * (1 + 噪声调制)
    float windForce = GrassWindStrength * (1.0 + NoiseSigned);
    
    // --- 持续偏移: 风力直接沿风向推动控制点 ---
    // P2 (66% 高度) 受较小的持续偏移
    float3 p2Offset = WindDir3D * windForce * 0.66 * GrassWindWaveAmplitude;
    // P3 (尖端) 受完整的持续偏移 + 额外尖端前推
    float3 p3Offset = WindDir3D * windForce * GrassWindWaveAmplitude
                    + WindDir3D * GrassWindPushTipForward * windForce;
    
    // --- 小幅波动: sin 波叠加在持续偏移之上，产生呼吸感 ---
    // 波动幅度远小于持续偏移，所以草叶不会反向回弹
    float phase = (ResolvedView.RealTime.x + hash * 6.28318) * GrassWindWaveSpeed;
    float p2Wave = sin(phase + 0.66 * 6.28318 * GrassWindSinOffsetRange);
    float p3Wave = sin(phase + 1.0 * 6.28318 * GrassWindSinOffsetRange);
    
    // 波动沿 bezCtrlOffsetDir (侧向) 施加，模拟风中的微小摇摆
    // 幅度 = windForce * 0.15，远小于持续偏移
    P2 += p2Offset + bezCtrlOffsetDir * p2Wave * windForce * 0.15 * 0.66;
    P3 += p3Offset + bezCtrlOffsetDir * p3Wave * windForce * 0.15;


    
    // Get position on bezier curve
    float3 CurvePos = CubicBezier(P0, P1, P2, P3, t);
    
    // Get tangent (up direction along blade)
    float3 UpTangent = CubicBezierTangent(P0, P1, P2, P3, t);
    float UpTangentLen = length(UpTangent);
    if (UpTangentLen > 0.001)
    {
        UpTangent = UpTangent / UpTangentLen;
    }
    else
    {
        UpTangent = float3(0, 0, 1);
    }
    
    // ========== 视角依赖旋转 (Ghost of Tsushima 风格) ==========
    // 当从侧面观看草叶时，让草叶轻微旋转朝向相机，使草地看起来更饱满
    float2 AdjustedFacingDir = FacingDir;
    
    // 计算从草叶位置指向相机的方向 (在世界空间 XY 平面上)
    float3 WorldPos = InstancePos + CurvePos; // 草叶当前位置的近似值
    // 注意: ResolvedView.WorldCameraOrigin 是 FDFVector3 类型 (双精度)
    // 使用 DFHackToFloat 将其转换为 float3
    float3 CameraWorldPos = DFHackToFloat(ResolvedView.WorldCameraOrigin);
    float3 ToCamera = CameraWorldPos - WorldPos;
    float2 ToCameraXY = normalize(ToCamera.xy);
    
    // 计算草叶朝向与相机方向的点积
    // 当点积接近 0 时，说明相机在草叶的侧面
    float DotWithCamera = dot(FacingDir, ToCameraXY);
    
    // 计算需要旋转的方向
    // 叉积的符号决定了应该向哪个方向旋转
    float CrossSign = sign(FacingDir.x * ToCameraXY.y - FacingDir.y * ToCameraXY.x);
    
    // 计算旋转量：当从侧面观看时旋转最大，正面或背面观看时不旋转
    // 使用 1 - abs(DotWithCamera) 来获取侧面程度
    float SideFactor = 1.0 - abs(DotWithCamera);
    float RotationAmount = SideFactor * GrassViewRotationAmount * CrossSign;
    
    // 使用 2D 旋转矩阵旋转朝向
    // 旋转角度较小时可以用近似: cos(a) ≈ 1, sin(a) ≈ a
    // 但为了更准确，我们使用实际的旋转
    float RotAngle = RotationAmount * 0.5; // 最大旋转约 28 度 (0.5 弧度)
    float CosRot = cos(RotAngle);
    float SinRot = sin(RotAngle);
    AdjustedFacingDir.x = FacingDir.x * CosRot - FacingDir.y * SinRot;
    AdjustedFacingDir.y = FacingDir.x * SinRot + FacingDir.y * CosRot;
    AdjustedFacingDir = normalize(AdjustedFacingDir);
    
    // Width direction (perpendicular to adjusted facing direction in XY plane)
    float3 WidthDir = float3(-AdjustedFacingDir.y, AdjustedFacingDir.x, 0);
    float WidthDirLen = length(WidthDir);
    if (WidthDirLen > 0.001)
    {
        WidthDir = WidthDir / WidthDirLen;
    }
    else
    {
        WidthDir = float3(1, 0, 0);
    }
    
    // Calculate normal: perpendicular to both width direction and up tangent
    // Normal points away from the blade surface (front face)
    // 使用调整后的朝向来计算法线
    float3 BladeNormal = cross(WidthDir, UpTangent);
    float NormalLen = length(BladeNormal);
    if (NormalLen > 0.001)
    {
        BladeNormal = BladeNormal / NormalLen;
    }
    else
    {
        // Fallback: use adjusted facing direction as normal
        BladeNormal = float3(AdjustedFacingDir.x, AdjustedFacingDir.y, 0);
    }
    
    // 应用弯曲法线效果
    // 使用顶点颜色的 G 通道 (VertexWidthRatio) 来确定弯曲方向
    BladeNormal = ApplyCurvedNormal(BladeNormal, WidthDir, VertexWidthRatio, GrassCurvedNormalAmount);
    
    // Apply width offset (LocalPos.x is the width offset)
    float3 FinalPos = CurvePos + WidthDir * LocalPos.x * WidthRatioScale;
    
    // Add instance position
    FinalPos += InstancePos;
    
    Result.Position = FinalPos;
    Result.Normal = BladeNormal;
    Result.Tangent = WidthDir;      // Tangent along width (U direction)
    Result.Bitangent = UpTangent;   // Bitangent along height (V direction)
#endif
    
    return Result;
}

// Simple offset-only version for depth passes
float3 GetGrassInstanceOffset(uint InstanceId)
{
#if USE_GRASS_INSTANCING
    return GrassInstancePositions[InstanceId];
#else
    return float3(0, 0, 0);
#endif
}

// Calculate tangent basis
float3x3 CalcTangentBasis(half3 TangentX, half4 TangentZ)
{
    half3 TangentXN = TangentBias(TangentX);
    half4 TangentZN = TangentBias(TangentZ);
    half3 TangentY = cross(TangentZN.xyz, TangentXN) * TangentZN.w;
    return float3x3(TangentXN, TangentY, TangentZN.xyz);
}

// ============================================================================
// Vertex Factory 核心函数
// ============================================================================

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
    FVertexFactoryIntermediates Intermediates;
    Intermediates.SceneData = VF_GPUSCENE_GET_INTERMEDIATES(Input);
    Intermediates.Color = Input.Color FCOLOR_COMPONENT_SWIZZLE;
    
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 0
    Intermediates.TexCoord0 = Input.TexCoord0;
#else
    Intermediates.TexCoord0 = float2(0, 0);
#endif
    
#if USE_GRASS_INSTANCING
    // 计算变形后的位置和法线
    FGrassDeformResult DeformResult = GetDeformedGrassPositionAndNormal(Input.Position.xyz, Input.InstanceId, Input.Color);
    
    // 使用变形后的切线空间
    Intermediates.DeformedNormal = DeformResult.Normal;
    Intermediates.DeformedTangent = DeformResult.Tangent;
    Intermediates.DeformedBitangent = DeformResult.Bitangent;
    
    // 构建 TangentToLocal 矩阵 (行向量: Tangent, Bitangent, Normal)
    Intermediates.TangentToLocal = float3x3(
        DeformResult.Tangent,
        DeformResult.Bitangent,
        DeformResult.Normal
    );
#else
    Intermediates.TangentToLocal = CalcTangentBasis(Input.TangentX, Input.TangentZ);
    Intermediates.DeformedNormal = Intermediates.TangentToLocal[2];
    Intermediates.DeformedTangent = Intermediates.TangentToLocal[0];
    Intermediates.DeformedBitangent = Intermediates.TangentToLocal[1];
#endif
    
    // 转换到世界空间
    Intermediates.TangentToWorld = mul(Intermediates.TangentToLocal, GetLocalToWorld3x3());
    
    return Intermediates;
}

// Main World Position calculation (with Bezier deformation)
float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    FDFMatrix LocalToWorld = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    
#if USE_GRASS_INSTANCING
    // Apply Bezier curve deformation
    FGrassDeformResult DeformResult = GetDeformedGrassPositionAndNormal(Input.Position.xyz, Input.InstanceId, Input.Color);
    float4 WorldPos = TransformLocalToTranslatedWorld(DeformResult.Position, LocalToWorld);
#else
    float4 WorldPos = TransformLocalToTranslatedWorld(Input.Position.xyz, LocalToWorld);
#endif
    
    return WorldPos;
}

// Position Only version (for depth pass)
float4 VertexFactoryGetWorldPosition(FPositionOnlyVertexFactoryInput Input)
{
    FDFMatrix LocalToWorld = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    
#if USE_GRASS_INSTANCING
    // 深度 pass 不需要弯曲法线，使用默认的中心值 (0.5)
    half4 DefaultColor = half4(0, 0.5, 1, 1);  // G = 0.5 表示中心，不弯曲
    FGrassDeformResult DeformResult = GetDeformedGrassPositionAndNormal(Input.Position.xyz, Input.InstanceId, DefaultColor);
    float4 WorldPos = TransformLocalToTranslatedWorld(DeformResult.Position, LocalToWorld);
#else
    float4 WorldPos = TransformLocalToTranslatedWorld(Input.Position.xyz, LocalToWorld);
#endif
    
    return WorldPos;
}

// Position And Normal Only version (for shadow depth pass)
float4 VertexFactoryGetWorldPosition(FPositionAndNormalOnlyVertexFactoryInput Input)
{
    FDFMatrix LocalToWorld = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    
#if USE_GRASS_INSTANCING
    // 阴影深度 pass 不需要弯曲法线，使用默认的中心值 (0.5)
    half4 DefaultColor = half4(0, 0.5, 1, 1);  // G = 0.5 表示中心，不弯曲
    FGrassDeformResult DeformResult = GetDeformedGrassPositionAndNormal(Input.Position.xyz, Input.InstanceId, DefaultColor);
    float4 WorldPos = TransformLocalToTranslatedWorld(DeformResult.Position, LocalToWorld);
#else
    float4 WorldPos = TransformLocalToTranslatedWorld(Input.Position.xyz, LocalToWorld);
#endif
    
    return WorldPos;
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    // 使用变形后的法线，转换到世界空间
    return normalize(mul(Intermediates.DeformedNormal, GetLocalToWorld3x3()));
}

float3 VertexFactoryGetWorldNormal(FPositionAndNormalOnlyVertexFactoryInput Input)
{
    FDFMatrix LocalToWorld = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    float3 InvScale = GetPrimitiveDataFromUniformBuffer().InvNonUniformScale;
    
#if USE_GRASS_INSTANCING
    // 阴影 pass 不需要弯曲法线，使用默认的中心值 (0.5)
    half4 DefaultColor = half4(0, 0.5, 1, 1);  // G = 0.5 表示中心，不弯曲
    FGrassDeformResult DeformResult = GetDeformedGrassPositionAndNormal(Input.Position.xyz, Input.InstanceId, DefaultColor);
    return RotateLocalToWorld(DeformResult.Normal, LocalToWorld, InvScale);
#else
    return RotateLocalToWorld(Input.Normal.xyz, LocalToWorld, InvScale);
#endif
}

float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
{
    return InWorldPosition;
}

float3 VertexFactoryGetPositionForVertexLighting(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 TranslatedWorldPosition)
{
    return TranslatedWorldPosition;
}

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    // 草地不需要运动模糊，返回当前位置
    return VertexFactoryGetWorldPosition(Input, Intermediates);
}

float3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.TangentToLocal;
}

// ============================================================================
// 材质参数
// ============================================================================

FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
    FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();
    
#if NUM_TEX_COORD_INTERPOLATORS
    UNROLL
    for (int UVIndex = 0; UVIndex < NUM_TEX_COORD_INTERPOLATORS / 2; ++UVIndex)
    {
        Result.TexCoords[(UVIndex * 2) + 0] = Interpolants.TexCoords[UVIndex].xy;
        Result.TexCoords[(UVIndex * 2) + 1] = Interpolants.TexCoords[UVIndex].zw;
    }
    #if (NUM_TEX_COORD_INTERPOLATORS & 1) == 1
        Result.TexCoords[NUM_TEX_COORD_INTERPOLATORS - 1] = Interpolants.TexCoords[NUM_TEX_COORD_INTERPOLATORS / 2].xy;
    #endif
#endif

    Result.VertexColor = Interpolants.Color;
    
    half3 TangentToWorld0 = Interpolants.TangentToWorld0.xyz;
    half4 TangentToWorld2 = Interpolants.TangentToWorld2;
    Result.TangentToWorld = AssembleTangentToWorld(TangentToWorld0, TangentToWorld2);
    Result.UnMirrored = TangentToWorld2.w;
    Result.TwoSidedSign = 1;
    
    return Result;
}

// 5参数版本 (引擎期望的签名)
FMaterialVertexParameters GetMaterialVertexParameters(
    FVertexFactoryInput Input,
    FVertexFactoryIntermediates Intermediates,
    float3 WorldPosition,
    float3x3 TangentToLocal,
    bool bIsPreviousFrame = false)
{
    FMaterialVertexParameters Result = MakeInitializedMaterialVertexParameters();
    Result.SceneData = Intermediates.SceneData;
    Result.WorldPosition = WorldPosition;
    Result.VertexColor = Intermediates.Color;
    Result.TangentToWorld = Intermediates.TangentToWorld;
    Result.PreSkinnedPosition = Input.Position.xyz;
    Result.PreSkinnedNormal = Intermediates.DeformedNormal;
    
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 0
    Result.TexCoords[0] = Intermediates.TexCoord0;
#endif

#if ENABLE_NEW_HLSL_GENERATOR
    EvaluateVertexMaterialAttributes(Result);
#endif
    Result.LWCData = MakeMaterialLWCData(Result);
    
    return Result;
}

// ============================================================================
// 插值数据
// ============================================================================

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
    FVertexFactoryInterpolantsVSToPS Interpolants;
    
#if NUM_TEX_COORD_INTERPOLATORS
    float2 CustomizedUVs[NUM_TEX_COORD_INTERPOLATORS];
    GetMaterialCustomizedUVs(VertexParameters, CustomizedUVs);
    GetCustomInterpolators(VertexParameters, CustomizedUVs);
    
    UNROLL
    for (int UVIndex = 0; UVIndex < NUM_TEX_COORD_INTERPOLATORS / 2; ++UVIndex)
    {
        Interpolants.TexCoords[UVIndex].xy = CustomizedUVs[UVIndex * 2 + 0];
        Interpolants.TexCoords[UVIndex].zw = CustomizedUVs[UVIndex * 2 + 1];
    }
    #if (NUM_TEX_COORD_INTERPOLATORS & 1) == 1
        Interpolants.TexCoords[NUM_TEX_COORD_INTERPOLATORS / 2].xy = CustomizedUVs[NUM_TEX_COORD_INTERPOLATORS - 1];
        Interpolants.TexCoords[NUM_TEX_COORD_INTERPOLATORS / 2].zw = 0.0f;
    #endif
#endif

    Interpolants.Color = Intermediates.Color;
    
    // 传递 LOD 级别到 Pixel Shader
    Interpolants.LODLevel = (float)GrassLODLevel;
    
    // 传递切线空间到世界空间的变换
    // TangentToWorld0 = Tangent (X axis of tangent space in world)
    // TangentToWorld2 = Normal (Z axis of tangent space in world), w = determinant sign
    Interpolants.TangentToWorld0.xyz = Intermediates.TangentToWorld[0];
    Interpolants.TangentToWorld0.w = 0;
    Interpolants.TangentToWorld2 = float4(Intermediates.TangentToWorld[2], sign(determinant(Intermediates.TangentToLocal)));
    
#if INSTANCED_STEREO
    Interpolants.EyeIndex = GetEyeIndexFromVF(Input);
#endif

#if VF_USE_PRIMITIVE_SCENE_DATA
    Interpolants.PrimitiveId = Intermediates.SceneData.PrimitiveId;
#endif
    
    return Interpolants;
}

// ============================================================================
// 其他必需接口
// ============================================================================

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return 0;
}

uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
#if VF_USE_PRIMITIVE_SCENE_DATA
    return Interpolants.PrimitiveId;
#else
    return 0;
#endif
}

#if VF_USE_PRIMITIVE_SCENE_DATA
void SetPrimitiveId(inout FVertexFactoryInterpolantsVSToPS Interpolants, uint PrimitiveId)
{
    Interpolants.PrimitiveId = PrimitiveId;
}
#endif

// Include 默认接口实现
#include "/Engine/Private/VertexFactoryDefaultInterface.ush"