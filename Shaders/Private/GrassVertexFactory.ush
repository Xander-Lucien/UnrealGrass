// GrassVertexFactory.ush
// Grass Vertex Factory with Bezier Curve Blade Deformation

#include "/Engine/Private/VertexFactoryCommon.ush"

// ============================================================================
// Grass Instance Buffers (bound by FGrassVertexFactoryShaderParameters)
// ============================================================================
#if USE_GRASS_INSTANCING
StructuredBuffer<float3> GrassInstancePositions;
StructuredBuffer<float4> GrassData0;  // Height, Width, Tilt, Bend
StructuredBuffer<float4> GrassData1;  // TaperAmount, FacingDir.x, FacingDir.y, P1Offset
StructuredBuffer<float> GrassData2;   // P2Offset
#endif

// ============================================================================
// Bezier Curve Functions
// ============================================================================
float3 CubicBezier(float3 P0, float3 P1, float3 P2, float3 P3, float t)
{
    float t2 = t * t;
    float t3 = t2 * t;
    float mt = 1.0 - t;
    float mt2 = mt * mt;
    float mt3 = mt2 * mt;
    return mt3 * P0 + 3.0 * mt2 * t * P1 + 3.0 * mt * t2 * P2 + t3 * P3;
}

float3 CubicBezierTangent(float3 P0, float3 P1, float3 P2, float3 P3, float t)
{
    float t2 = t * t;
    float mt = 1.0 - t;
    float mt2 = mt * mt;
    return 3.0 * mt2 * (P1 - P0) + 6.0 * mt * t * (P2 - P1) + 3.0 * t2 * (P3 - P2);
}

// ============================================================================
// 主输入结构
// ============================================================================
struct FVertexFactoryInput
{
    float4 Position : ATTRIBUTE0;
    half3 TangentX : ATTRIBUTE1;
    half4 TangentZ : ATTRIBUTE2;  // w = tangent basis determinant sign
    half4 Color : ATTRIBUTE3;
    
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 0
    float2 TexCoord0 : ATTRIBUTE4;
#endif

    VF_GPUSCENE_DECLARE_INPUT_BLOCK(13)
    VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
    VF_MOBILE_MULTI_VIEW_DECLARE_INPUT_BLOCK()
    
    uint VertexId : SV_VertexID;
    uint InstanceId : SV_InstanceID;
};

// ============================================================================
// Position Only 输入结构 (用于深度 Pass)
// ============================================================================
struct FPositionOnlyVertexFactoryInput
{
    float4 Position : ATTRIBUTE0;
    
    VF_GPUSCENE_DECLARE_INPUT_BLOCK(1)
    VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
    VF_MOBILE_MULTI_VIEW_DECLARE_INPUT_BLOCK()
    
    uint VertexId : SV_VertexID;
    uint InstanceId : SV_InstanceID;
};

// ============================================================================
// Position And Normal Only 输入结构 (用于阴影深度 Pass)
// ============================================================================
struct FPositionAndNormalOnlyVertexFactoryInput
{
    float4 Position : ATTRIBUTE0;
    float4 Normal : ATTRIBUTE2;
    
    VF_GPUSCENE_DECLARE_INPUT_BLOCK(1)
    VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
    VF_MOBILE_MULTI_VIEW_DECLARE_INPUT_BLOCK()
    
    uint VertexId : SV_VertexID;
    uint InstanceId : SV_InstanceID;
};

// ============================================================================
// VS -> PS 插值结构
// ============================================================================
struct FVertexFactoryInterpolantsVSToPS
{
    TANGENTTOWORLD_INTERPOLATOR_BLOCK
    
#if NUM_TEX_COORD_INTERPOLATORS
    float4 TexCoords[(NUM_TEX_COORD_INTERPOLATORS + 1) / 2] : PACKED_TEXCOORDS;
#endif

    float4 Color : TEXCOORD3;
    
#if INSTANCED_STEREO
    nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
#endif

#if VF_USE_PRIMITIVE_SCENE_DATA
    nointerpolation uint PrimitiveId : PRIMITIVE_ID;
#endif
};

// ============================================================================
// 中间数据结构
// ============================================================================
struct FVertexFactoryIntermediates
{
    float4 Color;
    FSceneDataIntermediates SceneData;
    float3x3 TangentToLocal;
    float3x3 TangentToWorld;
};

FPrimitiveSceneData GetPrimitiveData(FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.SceneData.Primitive;
}

// ============================================================================
// Helper Functions
// ============================================================================

// Get grass instance data and deform vertex position
float3 GetDeformedGrassPosition(float3 LocalPos, uint InstanceId)
{
#if USE_GRASS_INSTANCING
    // Get instance data
    float3 InstancePos = GrassInstancePositions[InstanceId];
    float4 Data0 = GrassData0[InstanceId];  // Height, Width, Tilt, Bend
    float4 Data1 = GrassData1[InstanceId];  // TaperAmount, FacingDir.x, FacingDir.y, P1Offset
    float P2Offset = GrassData2[InstanceId];
    
    float Height = Data0.x;
    float Width = Data0.y;
    float Tilt = Data0.z;
    float Bend = Data0.w;
    float TaperAmount = Data1.x;
    float2 FacingDir = float2(Data1.y, Data1.z);
    float P1Offset = Data1.w;
    
    // Normalized height along blade (0 = root, 1 = tip)
    // Use vertex Z position normalized by default blade height (70.819 cm from original mesh)
    float DefaultBladeHeight = 70.819;
    float t = saturate(LocalPos.z / DefaultBladeHeight);
    
    // Width taper (narrower at top)
    float WidthScale = lerp(1.0, 1.0 - TaperAmount, t);
    float FinalWidth = Width * WidthScale;
    float OriginalWidth = 3.445;  // Original blade half-width in cm
    float WidthRatio = FinalWidth / (OriginalWidth * 2.0);
    
    // Build bezier control points
    float TiltAmount = Tilt * Height;
    
    float3 P0 = float3(0, 0, 0);
    float3 P1 = float3(FacingDir.x * P1Offset * TiltAmount, 
                       FacingDir.y * P1Offset * TiltAmount, 
                       Height * 0.33);
    float3 P2 = float3(FacingDir.x * P2Offset * TiltAmount + FacingDir.x * Bend * Height * 0.5,
                       FacingDir.y * P2Offset * TiltAmount + FacingDir.y * Bend * Height * 0.5,
                       Height * 0.66);
    float3 P3 = float3(FacingDir.x * TiltAmount,
                       FacingDir.y * TiltAmount,
                       Height);
    
    // Get position on bezier curve
    float3 CurvePos = CubicBezier(P0, P1, P2, P3, t);
    
    // Get tangent for width direction
    float3 Tangent = CubicBezierTangent(P0, P1, P2, P3, t);
    float TangentLen = length(Tangent);
    if (TangentLen > 0.001)
    {
        Tangent = Tangent / TangentLen;
    }
    else
    {
        Tangent = float3(0, 0, 1);
    }
    
    // Width direction (perpendicular to tangent in XY plane)
    float3 WidthDir = float3(-FacingDir.y, FacingDir.x, 0);
    float WidthDirLen = length(WidthDir);
    if (WidthDirLen > 0.001)
    {
        WidthDir = WidthDir / WidthDirLen;
    }
    else
    {
        WidthDir = float3(1, 0, 0);
    }
    
    // Apply width offset (LocalPos.x is the width offset)
    float3 FinalPos = CurvePos + WidthDir * LocalPos.x * WidthRatio;
    
    // Add instance position
    FinalPos += InstancePos;
    
    return FinalPos;
#else
    return LocalPos;
#endif
}

// Simple offset-only version for depth passes
float3 GetGrassInstanceOffset(uint InstanceId)
{
#if USE_GRASS_INSTANCING
    return GrassInstancePositions[InstanceId];
#else
    return float3(0, 0, 0);
#endif
}

// Calculate tangent basis
float3x3 CalcTangentBasis(half3 TangentX, half4 TangentZ)
{
    half3 TangentXN = TangentBias(TangentX);
    half4 TangentZN = TangentBias(TangentZ);
    half3 TangentY = cross(TangentZN.xyz, TangentXN) * TangentZN.w;
    return float3x3(TangentXN, TangentY, TangentZN.xyz);
}

// ============================================================================
// Vertex Factory 核心函数
// ============================================================================

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
    FVertexFactoryIntermediates Intermediates;
    Intermediates.SceneData = VF_GPUSCENE_GET_INTERMEDIATES(Input);
    Intermediates.Color = Input.Color FCOLOR_COMPONENT_SWIZZLE;
    Intermediates.TangentToLocal = CalcTangentBasis(Input.TangentX, Input.TangentZ);
    Intermediates.TangentToWorld = mul(Intermediates.TangentToLocal, GetLocalToWorld3x3());
    return Intermediates;
}

// Main World Position calculation (with Bezier deformation)
float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    FDFMatrix LocalToWorld = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    
#if USE_GRASS_INSTANCING
    // Apply Bezier curve deformation
    float3 DeformedPos = GetDeformedGrassPosition(Input.Position.xyz, Input.InstanceId);
    float4 WorldPos = TransformLocalToTranslatedWorld(DeformedPos, LocalToWorld);
#else
    float4 WorldPos = TransformLocalToTranslatedWorld(Input.Position.xyz, LocalToWorld);
#endif
    
    return WorldPos;
}

// Position Only version (for depth pass - use simple offset for performance)
float4 VertexFactoryGetWorldPosition(FPositionOnlyVertexFactoryInput Input)
{
    FDFMatrix LocalToWorld = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    
#if USE_GRASS_INSTANCING
    float3 DeformedPos = GetDeformedGrassPosition(Input.Position.xyz, Input.InstanceId);
    float4 WorldPos = TransformLocalToTranslatedWorld(DeformedPos, LocalToWorld);
#else
    float4 WorldPos = TransformLocalToTranslatedWorld(Input.Position.xyz, LocalToWorld);
#endif
    
    return WorldPos;
}

// Position And Normal Only version (for shadow depth pass)
float4 VertexFactoryGetWorldPosition(FPositionAndNormalOnlyVertexFactoryInput Input)
{
    FDFMatrix LocalToWorld = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    
#if USE_GRASS_INSTANCING
    float3 DeformedPos = GetDeformedGrassPosition(Input.Position.xyz, Input.InstanceId);
    float4 WorldPos = TransformLocalToTranslatedWorld(DeformedPos, LocalToWorld);
#else
    float4 WorldPos = TransformLocalToTranslatedWorld(Input.Position.xyz, LocalToWorld);
#endif
    
    return WorldPos;
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.TangentToWorld[2];
}

float3 VertexFactoryGetWorldNormal(FPositionAndNormalOnlyVertexFactoryInput Input)
{
    FDFMatrix LocalToWorld = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    float3 InvScale = GetPrimitiveDataFromUniformBuffer().InvNonUniformScale;
    return RotateLocalToWorld(Input.Normal.xyz, LocalToWorld, InvScale);
}

float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
{
    return InWorldPosition;
}

float3 VertexFactoryGetPositionForVertexLighting(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 TranslatedWorldPosition)
{
    return TranslatedWorldPosition;
}

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    // 草地不需要运动模糊，返回当前位置
    return VertexFactoryGetWorldPosition(Input, Intermediates);
}

float3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.TangentToLocal;
}

// ============================================================================
// 材质参数
// ============================================================================

FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
    FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();
    
#if NUM_TEX_COORD_INTERPOLATORS
    UNROLL
    for (int UVIndex = 0; UVIndex < NUM_TEX_COORD_INTERPOLATORS / 2; ++UVIndex)
    {
        Result.TexCoords[(UVIndex * 2) + 0] = Interpolants.TexCoords[UVIndex].xy;
        Result.TexCoords[(UVIndex * 2) + 1] = Interpolants.TexCoords[UVIndex].zw;
    }
    #if (NUM_TEX_COORD_INTERPOLATORS & 1) == 1
        Result.TexCoords[NUM_TEX_COORD_INTERPOLATORS - 1] = Interpolants.TexCoords[NUM_TEX_COORD_INTERPOLATORS / 2].xy;
    #endif
#endif

    Result.VertexColor = Interpolants.Color;
    
    half3 TangentToWorld0 = Interpolants.TangentToWorld0.xyz;
    half4 TangentToWorld2 = Interpolants.TangentToWorld2;
    Result.TangentToWorld = AssembleTangentToWorld(TangentToWorld0, TangentToWorld2);
    Result.UnMirrored = 1;
    Result.TwoSidedSign = 1;
    
    return Result;
}

// 5参数版本 (引擎期望的签名)
FMaterialVertexParameters GetMaterialVertexParameters(
    FVertexFactoryInput Input,
    FVertexFactoryIntermediates Intermediates,
    float3 WorldPosition,
    float3x3 TangentToLocal,
    bool bIsPreviousFrame = false)
{
    FMaterialVertexParameters Result = MakeInitializedMaterialVertexParameters();
    Result.SceneData = Intermediates.SceneData;
    Result.WorldPosition = WorldPosition;
    Result.VertexColor = Intermediates.Color;
    Result.TangentToWorld = mul(TangentToLocal, GetLocalToWorld3x3());
    Result.PreSkinnedPosition = Input.Position.xyz;
    Result.PreSkinnedNormal = TangentToLocal[2].xyz;
    
#if NUM_MATERIAL_TEXCOORDS_VERTEX > 0
    Result.TexCoords[0] = Input.TexCoord0;
#endif

#if ENABLE_NEW_HLSL_GENERATOR
    EvaluateVertexMaterialAttributes(Result);
#endif
    Result.LWCData = MakeMaterialLWCData(Result);
    
    return Result;
}

// ============================================================================
// 插值数据
// ============================================================================

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
    FVertexFactoryInterpolantsVSToPS Interpolants;
    
#if NUM_TEX_COORD_INTERPOLATORS
    float2 CustomizedUVs[NUM_TEX_COORD_INTERPOLATORS];
    GetMaterialCustomizedUVs(VertexParameters, CustomizedUVs);
    GetCustomInterpolators(VertexParameters, CustomizedUVs);
    
    UNROLL
    for (int UVIndex = 0; UVIndex < NUM_TEX_COORD_INTERPOLATORS / 2; ++UVIndex)
    {
        Interpolants.TexCoords[UVIndex].xy = CustomizedUVs[UVIndex * 2 + 0];
        Interpolants.TexCoords[UVIndex].zw = CustomizedUVs[UVIndex * 2 + 1];
    }
    #if (NUM_TEX_COORD_INTERPOLATORS & 1) == 1
        Interpolants.TexCoords[NUM_TEX_COORD_INTERPOLATORS / 2].xy = CustomizedUVs[NUM_TEX_COORD_INTERPOLATORS - 1];
        Interpolants.TexCoords[NUM_TEX_COORD_INTERPOLATORS / 2].zw = 0.0f;
    #endif
#endif

    Interpolants.Color = Intermediates.Color;
    
    Interpolants.TangentToWorld0.xyz = Intermediates.TangentToWorld[0];
    Interpolants.TangentToWorld0.w = 0;
    Interpolants.TangentToWorld2 = float4(Intermediates.TangentToWorld[2], sign(determinant(Intermediates.TangentToLocal)));
    
#if INSTANCED_STEREO
    Interpolants.EyeIndex = GetEyeIndexFromVF(Input);
#endif

#if VF_USE_PRIMITIVE_SCENE_DATA
    Interpolants.PrimitiveId = Intermediates.SceneData.PrimitiveId;
#endif
    
    return Interpolants;
}

// ============================================================================
// 其他必需接口
// ============================================================================

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return 0;
}

uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
#if VF_USE_PRIMITIVE_SCENE_DATA
    return Interpolants.PrimitiveId;
#else
    return 0;
#endif
}

#if VF_USE_PRIMITIVE_SCENE_DATA
void SetPrimitiveId(inout FVertexFactoryInterpolantsVSToPS Interpolants, uint PrimitiveId)
{
    Interpolants.PrimitiveId = PrimitiveId;
}
#endif

// Include 默认接口实现
#include "/Engine/Private/VertexFactoryDefaultInterface.ush"